%% <% _ = assigns %>
%% Autogenerated with Rez v<%= Rez.version() %>
%% ** Do not modify as local changes will be overwritten every time the game is compiled **

%% ----------------------------------------------------------------------------
%% Head Assets
%% ----------------------------------------------------------------------------

@asset _ALPINE_JS begin
  file_name: "alpinejs.min.js"
  defer: true
  pre_runtime: true
end

@asset _BULMA_CSS begin
  file_name: "bulma.min.css"
end

@asset _PLURALIZE_JS begin
  file_name: "pluralize.js"
  defer: false
  pre_runtime: true
end

@asset _TRACERY_JS begin
  file_name: "tracery.js"
  defer: false
  pre_runtime: true
end

%% ----------------------------------------------------------------------------
%% JS Library Patches
%% ----------------------------------------------------------------------------

@script begin
function isObject(obj) {
  return obj !== null && typeof obj === "object" && Object.prototype.toString.call(obj) === "[object Object]";
}
end

@patch OBJECT_DEEP_COPY begin
  patch: "Object"
  method: "copy"
  impl: function() {
    // Handle null or undefined
    if (this === null || typeof this === 'undefined') {
        return this;
    }

    // Handle array
    if (Array.isArray(this)) {
        const copiedArr = [];
        for (let i = 0; i < this.length; i++) {
            copiedArr[i] = this[i].copy();
        }
        return copiedArr;
    }

    // Handle object
    if (typeof this === 'object') {
        const copiedObj = {};
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                copiedObj[key] = this[key].copy();
            }
        }
        return copiedObj;
    }

    // Handle other primitive types (e.g., string, number, etc.)
    return this;
  }
end

@patch OBJECT_OBJ_MAP begin
  patch: "Object"
  method: "obj_map"
  impl: function(f) {
    const entries = Object.entries(this);
    const new_entries = entries.map(([k, v]) => [k, f(v, k)]);
    return Object.fromEntries(new_entries);
  }
end

@patch OBJECT_DQ_WRAP begin
  patch: "Object"
  method: "dq_wrap"
  impl: function() {
    return "\"" + this + "\"";
  }
end

@patch ARRAY_FY_SHUFFLE begin
  %% Fisher-Yates Shuffle impl from: https://sebhastian.com/fisher-yates-shuffle-javascript/
  patch: "Array"
  method: "fy_shuffle"
  impl: function() {
    let idx = this.length;
    while(--idx > 0) {
      const rand_idx = Math.floor(Math.random() * (idx+1));
      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];
    }
    return this;
  }
end

@patch ARRAY_RANDOM_ELEMENT begin
  patch: "Array"
  method: "randomElement"
  impl: function() {
    return this.at(Math.floor(Math.random() * this.length));
  }
end

@patch ARRAY_RANDOM_INDEX begin
  patch: "Array"
  method: "randomIndex"
  impl: function() {
    return Math.floor(Math.random() * this.length);
  }
end

@patch ARRAY_FREQUENCIES begin
  patch: "Array"
  method: "frequencies"
  impl: function() {
    const freqs = new Map();
    for(const v of this) {
      let val = freqs.get(v);
      if(typeof(val) == "undefined") {
        val = 1;
      } else {
        val = val + 1;
      }
      freqs.set(v, val);
    }
    return freqs;
  }
end

@patch ARRAY_SUM begin
  patch: "Array"
  method: "sum"
  impl: function() {
    return this.reduce((a, b) => a+b, 0);
  }
end

@patch ARRAY_EQUALS begin
  patch: "Array"
  function: "equals"
  impl: function(a, b) {
    return Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        a.every((val, index) => val === b[index]);
  }
end

@patch ARRAY_PAIRS begin
  patch: "Array"
  method: "to_pairs"
  impl: function() {
    let pairs = [];
    for(let i = 0; i < this.length; i += 2) {
      if(this[i + 1] !== undefined) {
        pairs.push([this[i], this[i + 1]]);
      }
    }
    return pairs;
  }
end

@patch STRING_INTERPOLATE begin
  patch: "String"
  method: "interpolate"
  impl: function(game) {
    return this;
  }
end

@patch STRING_TO_SNAKE_CASE begin
  patch: "String"
  method: "toSnakeCase"
  impl: function() {
      return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('_');
  }
end

@patch STRING_PARSE_TIME begin
  patch: "String"
  method: "parseTime"
  impl: function() {
    const time_components = this.match( /(\d+)(?::(\d\d))?\s*(p?)/ );
    const hour_s = time_components[1];
    if(typeof(hour_s) == "undefined") {
      throw "Invalid time string (hour): '" + this + "'";
    }
    const hour = parseInt(hour_s);
    if(hour == NaN) {
      throw "Invalid time string (hour): '" + this + "'";
    }

    const mins_s = time_components[2];
    if(typeof(mins_s) == "undefined") {
      throw "Invalid time string (mins): '" + this + "'";
    }

    const mins = parseInt(mins_s);
    if(typeof(mins) == NaN) {
      throw "Invalid time string (mins): '" + this + "'";
    }

    return [hour, mins];
  }
end

@patch STRING_RANDOM_ID begin
  patch: "String"
  function: "randomId"
  impl: function() {
    const rand = window.crypto.getRandomValues(new Uint32Array(1))[0];
    return rand.toString(16);
  }
end

@patch STRING_WRAP_WITH begin
  patch: "String"
  method: "wrapWith"
  impl: function(prefix, suffix) {
    return prefix + this + suffix;
  }
end

%% Some helpful set functions from:
%% https://medium.com/@alvaro.saburido/set-theory-for-arrays-in-es6-eb2f20a61848
%% https://stackoverflow.com/a/31129384/7518

@patch SET_UNION begin
  patch: "Set"
  method: "union"
  impl: function(otherSet) {
    return new Set([...this, ...otherSet]);
  }
end

@patch SET_INTERSECTION begin
  patch: "Set"
  method: "intersection"
  impl: function(otherSet) {
    return new Set([...this].filter(x => otherSet.has(x)));
  }
end

@patch SET_DIFFERENCE begin
  patch: "Set"
  method: "difference"
  impl: function(otherSet) {
    return new Set([...this].filter(x => !otherSet.has(x)));
  }
end

@patch SET_EQUALS begin
  patch: "Set"
  method: "equals"
  impl: function(otherSet) {
    return this.size === otherSet.size &&
    [...this].every((x) => otherSet.has(x));
  }
end

@patch SET_HAS_SUBSET begin
  patch: "Set"
  method: "hasSubset"
  impl: function(otherSet) {
    return this.intersection(otherSet).equals(otherSet);
  }
end

@patch NUMBER_RANGE begin
  patch: "Number"
  function: "range"
  impl: function(from, to, step) {
    step ??= 1;

    if(from>to) {
      [from, to] = [to, from];
    }

    return Array.from(
      {length: (to-from)/step+1},
      (_, i) => from + (i * step));
  }
end

@patch NUMBER_RND_BETWEEN begin
  patch: "Number"
  function: "rand_between"
  impl: function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }
    return Math.floor(min + Math.random() * (max - min + 1));
  }
end

@patch NUMBER_RNDF_BETWEEN begin
  patch: "Number"
  function: "randf_between"
  impl: function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }

    return min + (Math.random() * (max - min));
  }
end

@patch NUMBER_ROUNDP begin
  %% https://stackoverflow.com/questions/7342957/how-do-you-round-to-1-decimal-place-in-javascript
  patch: "Number"
  method: "roundp"
  impl: function(precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(this * multiplier) / multiplier;
  }
end

@patch NUMBER_CL_AVG begin
  patch: "Number"
  method: "cl_avg"
  impl: function(rounds) {
    rounds ??= 2;
    const f = Math.random() < 0.5 ? Math.ceil : Math.floor;
    return f(this/rounds);
  }
end

@patch NUMBER_ROUND_TO_NEAREST_HALF begin
  %% rounds a number to the nearest 0.5
  patch: "Number"
  method: "r2nh"
  impl: function() {
    return Math.round(this * 2) / 2;
  }
end

@patch NUMBER_DIST_ROUND begin
  patch: "Number"
  method: "dist_round"
  impl: function() {
    return Math.dist_round(this);
  }
end

@patch MATH_DIST_ROUND begin
  %% Because JS only gives us random numbers as floating point we sometimes
  %% end up having to round when we want an. The question is whether we round
  %% up or round down which can create a bias. The dist_round function randomly
  %% round up or down to distribute values evenly.
  patch: "Math"
  function: "dist_round"
  impl: function(v) {
    if(Math.random() < 0.5) {
      return Math.ceil(v);
    } else {
      return Math.floor(v);
    }
  }
end

@patch MATH_RAND_INT begin
  patch: "Math"
  function: "rand_int"
  impl: function(lim) {
    return Math.floor(Math.random() * lim);
  }
end

@patch MATH_CLRAND_INT begin
  patch: "Math"
  function: "clrand_int"
  impl: function(lim) {
    const v1 = Math.rand_int(lim);
    const v2 = Math.rand_int(lim);
    return (v1+v2)/2;
  }
end

@patch MATH_CLRANDR_INT begin
  patch: "Math"
  function: "clrandr_int"
  impl: function(lo, hi) {
    const v1 = Number.rnd_between(lo, hi);
    const v2 = Number.rnd_between(lo, hi);
    return Math.dist_round((v1+v2)/2);
  }
end

%% ----------------------------------------------------------------------------
%% Template Filters
%% ----------------------------------------------------------------------------

@filter COMPARE_EQ_FILTER begin
  %% v -> v -> bool

  name: "eq"
  impl: (v1, v2) => {return v1 === v2;}
end

@filter COMPARE_NE_FILTER begin
  %% v -> v -> bool

  name: "ne"
  impl: (v1, v2) => {return !(v1 === v2);}
end

@filter COMPARE_GT_FILTER begin
  %% n -> n -> bool

  name: "gt"
  impl: (n1, n2) => {return n1 > n2;}
end

@filter COMPARE_GTE_FILTER begin
  %% n -> n -> bool

  name: "gte"
  impl: (n1, n2) => {return n1 >= n2;}
end

@filter COMPARE_LT_FILTER begin
  %% n -> n -> bool

  name: "lt"
  impl: (n1, n2) => {return n1 < n2;}
end

@filter COMPARE_LTE_FILTER begin
  %% n -> n -> bool

  name: "lte"
  impl: (n1, n2) => {return n1 <= n2;}
end

@filter BSEL_FILTER begin
  %% bool -> array -> any

  name: "bsel"
  impl: (sel, options) => {return options[sel ? 0 : 1];}
end

@filter SEL_FILTER begin
  %% n -> array -> any

  name: "sel"
  impl: (idx, options) => {return options[idx];}
end

@filter ADD_FILTER begin
  %% n -> n

  name: "add"
  impl: (n, x) => {return n+x;}
end

@filter SUB_FILTER begin
  %% n -> n

  name: "sub"
  impl: (n, x) => {return n-x;}
end

@filter MUL_FILTER begin
  %% n -> n

  name: "mul"
  impl: (n, x) => {return n*x;}
end

@filter DIV_FILTER begin
  %% n -> n

  name: "div"
  impl: (n, x) => {return n/x;}
end

@filter MOD_FILTER begin
  %% n -> n

  name: "mod"
  impl: (n, x) => {return n % x;}
end

@filter ABS_FILTER begin
  %% n -> n

  name: "abs"
  impl: (n) => {return Math.abs(n)}
end

@filter NEG_FILTER begin
  %% n -> n

  name: "neg"
  impl: (n) => {return -n;}
end

@filter INC_FILTER begin
  %% n -> n

  name: "inc"
  impl: (n) => {return n+1;}
end

@filter DEC_FILTER begin
  %% n -> n

  name: "dec"
  impl: (n) => {return n-1;}
end

@filter ROUND_FILTER begin
  %% n -> n

  name: "round"
  impl: (n, dp) => {return n.roundp(dp);}
end

@filter STRING_MAKE_FILTER begin
  %% any -> String

  name: "string"
  impl: (s) => {return ""+s;}
end

@filter STRING_APPEND_FILTER begin
  %% String -> String

  name: "append"
  impl: (s, t) => {return s + t;}
end

@filter STRING_CAMELIZE_FILTER begin
  %% String -> String

  name: "camelize"
  impl: (s) => {return s.replace(/[_.-](\w|$)/g, function (_, x) {
		return x.toUpperCase();
	});}
end

@filter STRING_TRIM_FILTER begin
  %% String -> String
  %% ${"  Foo  " | trim} => foo

  name: "trim"
  impl: (s) => {return s.trim();}
end

@filter STRING_CAPITALIZE_FILTER begin
  %% String -> String
  name: "capitalize"
  impl: (s) => {return s.replace(/(^|\s)\S/g, l => l.toUpperCase());}
end

@filter STRING_DOWNCASE_FILTER begin
  %% String -> String

  name: "downcase"
  impl: (s) => {return s.toLowerCase();}
end

@filter STRING_PREPEND_FILTER begin
  %% String -> String

  name: "prepend"
  impl: (s, t) => {return t + s;}
end

@filter STRING_UPCASE_FILTER begin
  %% String -> String

  name: "upcase"
  impl: (s) => {return s.toUpperCase();}
end

@filter STRING_PLURALIZE_FILTER begin
  %% String -> String

  name: "pluralize"
  impl: (s) => {return pluralize(s);}
end

@filter STRING_SPLIT_FILTER begin
  %% String -> Array

  name: "split"
  impl: (s, p) => {return s.split(p);}
end

@filter STRING_STARTS_WITH_FILTER begin
  %% String -> Bool

  name: "starts_with"
  impl: (s, search) => {return s.startsWith(search);}
end

@filter STRING_ENDS_WITH_FILTER begin
  %% String -> Bool

  name: "ends_with"
  impl: (s, search) => {return s.endsWith(search);}
end

@filter STRING_CONTAINS_FILTER begin
  %% String -> Bool

  name: "contains"
  impl: (s, search) => {return s.includes(search);}
end

@filter EVENT_LINK_FILTER begin
  %% String -> Link

  %% ${<Title> | event: <event-id>}
  %% ${"Go here" | event: "fudge"}

  name: "event"
  impl: (event, title) => {
    return "<a href='javascript:void(0);' class='event' data-event='" + event + "'>" + title + "</a>";
  }
end

@filter DECISION_FILTER begin
  %% ${card | decision: <action>}
  %% ${card | decision: "can_attack"}

  name: "decision"
  impl: (card, action) => {
    const link_handler = card.getAttribute(action);
    if(typeof(link_handler) != "function") {
      throw `Attribute |${action}| of card |${card.id}| is not a handler function!`;
    } else {
      let link = new RezDynamicLink(card);
      link_handler(link);
      if(!link.choosen) {
        throw new Error("Choice must call one of hide/deny/allow!");
      }
      if(link.display) {
        return link.markup;
      } else {
        return "";
      }
    }
  }
end

@filter CARD_LINK_FILTER begin
  name: "card_link"
  impl: (card_id, title, css_class) => {
    css_class = css_class ?? "";
    return `<a href="javascript:void(0);" class="${css_class}" data-event="card" data-target="${card_id}">${title}</a>`;
  }
end

@filter SCENE_CHANGE_FILTER begin
  %% ${card | scene_change: <scene_id>, <title>}
  %% ${card | scene_change: "new_scene_id", "Action leading to a new scene"}

  name: "scene_change"
  impl: (card, scene_id, title) => {
    return "<a href='javascript:void(0);' data-event='shift' data-target='" + scene_id + "'>" + title + "</a>";
  }
end

@filter SCENE_INTERLUDE_FILTER begin
  %% ${card | scene_interlude: <scene_id>, <title>}
  %% ${card | scene_interlude: "new_scene_id", "Action leading to a scene interrupt"}

  name: "scene_interlude"
  impl: (card, scene_id, title) => {
    return "<a href='javascript:void(0);' data-event='interlude' data-target='" + scene_id + "'>" + title + "</a>";
  }
end

@filter SCENE_RESUME_FILTER begin
  %% ${card | scene_resume: <title>}
  %% ${card | scene_resume "Back to game"}

  name: "scene_resume"
  impl: (title) => {
    return "<a href='javascript:void(0);' data-event='resume'>" + title + "</a>";
  }
end

@filter ASSET_TAG_FILTER begin
  %% ${asset_id | asset_tag}

  name: "asset_tag"
  impl: (asset_id) => {
    const asset = $(asset_id);
    if(asset == null) {
      throw "Attempt to retrieve asset with id '" + asset_id + "' not found!";
    } else if(asset.game_object_type != "asset") {
      throw "Attempt to retrieve asset with id '" + asset_id + "' but found '" + asset.game_object_type + "'!";
    } else {
      return asset.tag();
    }
  }
end

@filter ASSET_PATH_FILTER begin
  %% ${asset_id | asset_path}
  %% ${"image_01" | asset_path}

  name: "asset_path"
  impl: (asset_id) => {
    const asset = $(asset_id);
    if(asset == null) {
      throw "Attempt to retrieve asset with id '" + asset_id + "' not found!";
    } else if(asset.game_object_type != "asset") {
      throw "Attempt to retrieve asset with id '" + asset_id + "' but found '" + asset.game_object_type + "'!";
    } else {
      return asset.path;
    }
  }
end

%% ----------------------------------------------------------------------------
%% A scene that handles loading a game
%% ----------------------------------------------------------------------------

@scene default_load_game begin
    initial_card: #default_load_game_form
    layout: ```
    ${content}
    ```
    layout_mode: :single
  end

@card default_load_game_form begin
  content: ```
  <form name="load_form">
    <input type="file" name="data"/>
    <input type="submit"/>
  </form>
  ```

  on_load_form: (card, data) => {
    console.log("In the load form handler!");
    const form = data.form;
    const file_input = form.querySelector("input[type=file]");
    const [file] = file_input.files;
    const reader = new FileReader();
    reader.addEventListener("load", function() {
      window.game.load(reader.result);
      window.game.render();
    });
    reader.readAsText(file);
  }
end

%% ----------------------------------------------------------------------------
%% Default Behaviour Tasks
%% ----------------------------------------------------------------------------

@system actor_behaviours begin
  enabled: true
  priority: 10
  on_tick: (event) => {
    console.log("Running actor_behaviours system");
    const game = event.game;
    const actors = game.getAll("actor").filter((actor) => {return actor.hasAttribute("behaviours")});
    const wmem = {};
    actors.forEach((actor) => {
      const btree = actor.getAttributeValue("behaviours");
      btree.execute(wmem);
    });
  }
end

%% Standard behaviours
%% By convention we give behaviours an UPPER CASE id to make it less likely
%% they will clash with author generated id's. The core of these behaviours
%% model the 'generic' behaviours implemented in the Crysis engine:
%% https://docs.cryengine.com/display/CEPROG/Modular+Behavior+Tree+Nodes
%% See the Behaviour Tree part of the user guide for more information.

@task SELECT begin
  %% The SELECT task executes it's children in turn until one of them
  %% succeeds, then SELECT succeeds. If no child succeeeds then SELECT fails.

  $template: true
  options: []
  min_children: 2

  execute: (task, wmem) => {
    let result = {success: true, wmem: wmem};
    for(const child of task.children) {
      result = child.execute(result.wmem);
      if(result.success) {
        break;
      }
    }
    return result;
  }
end

@task SELECT_P begin
  %% The SELECT_P task is similar to SELECT except that before ticking any
  %% child it does a probability check using the "p" option. If the check passes
  %% it ticks the child, otherwise it moves on to the next child. If a child
  %% succeeds SELECT_P succeeds. If no child succeeds, SELECT_P fails.

  $template: true
  options: [:p]
  min_children: 2

  configure: (task) => {
    const p = task.intOption("p");
    if(p < 0 || p > 100) {
      throw "Task: " + task.id + " invalid 'p' option specified.";
    }
  }

  execute: (task, wmem) => {
    const p = task.intOption("p");
    const die = new RezDie(1, 100, 0);
    let result = {success: false, id: task.id, wmem};
    for(const child of task.children) {
      if(die.roll() < p) {
        result = child.execute(result.wmem);
        if(result.success) {
          break;
        }
      }
    }
    return result;
  }
end

@task SEQUENCE begin
  %% The SEQUENCE task executes its children in turn. If they all succeed
  %% then the SEQUENCE succeeds. If a child fails the SEQUENCE fails and does
  %% not execute any further children.

  $template: true
  options: []
  min_children: 2

  execute: (task, wmem) => {
    let result = {success: true, wmem: wmem};
    for(const child of task.children) {
      result = child.tick(result.wmem);
      if(result.success) {
        break;
      }
    }

    return result;
  }
end

@task LOOP begin
  %% The LOOP task takes one child and executes it 'count' times. If it
  %% succeeds on every repetition the LOOP succeeds. If the child ever fails
  %% the LOOP fails.

  $template: true
  options: [:count]
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    const count = task.option("count");
    let result = {success: false, wmem: wmem};
    for(let i=0; i<count; i++) {
      result = this.firstChild().tick(result.wmem);
      if(!result.success) {
        return result;
      }
    }

    return result;
  }
end

@task LOOP_UNTIL begin
  %% The LOOP_UNTIL task takes one child and executes it until it
  %% succeeds. The 'attempts' option specifies how many times it will
  %% executed. If the child ever succeeds, LOOP_UNTIL succeeds. If the
  %% child doesn't succeed in the number of attempts then LOOP_UNTIL fails.

  $template: true
  options: [:attempts]
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    let result = {success: false, wmem: wmem};
    for(let i=0; i<this.count(); i++) {
      result = this.firstChild().tick(result.db);
      if(result.success) {
        break;
      }
    }

    return result;
  }
end

@task MAYBE begin
  %% The MAYBE task takes one child and based on the option "p" determines
  %% whether to execute it or not. If it executes the child then MAYBE succeeds
  %% if the child succeeds or fails if the child fails. If it doesn't execute
  %% the child then MAYBE fails.

  $template: true
  options: [:p]
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    const p = task.option("p");
    const die = new RezDie(1, 100, 0);

    if(die.roll() < p) {
      return task.firstChild().execute(wmem);
    } else {
      return {success: false, id: task.id, error: "Didn't execute"};
    }
  }
end

@task EITHER begin
  %% The EITHER task takes two children and based on the probability
  %% option "p" determines whether to execute the first or second child.
  %% Having decided which child to execute EITHER succeeds or fails based
  %% on whether the selected child succeeds or fails.

  $template: true
  options: [:p]
  min_children: 2
  max_children: 2

  execute: (task, wmem) => {
    const p = task.option("p");
    const die = new RezDie(1, 100, 0);
    const roll = die.roll();

    if(roll < p) {
      return task.firstChild().execute(wmem);
    } else {
      return task.secondChild().execute(wmem);
    }
  }
end

@task RANDOM_CHOICE begin
  %% The RANDOM_CHOICE task takes two or more children. When RANDOM_CHOICE
  %% executes it selects a child at random and executes it. If that child
  %% succeeds then RANDOM_CHOICE succeeds, otherwise it fails.

  $template: true
  options: []
  min_children: 2

  execute: (task, wmem) => {
    const die = new RezDie(1, task.childCount(), 0);
    const child = task.getChild(die.roll());
    return child.execute(wmem);
  }
end

@task RANDOM_EACH begin
  %% The RANDOM_EACH task takes two or more children. When RANDOM_EACH
  %% executes it selects a child, without replacement, and executes it. If
  %% the selected child succeeds then RANDOM_EACH succeeds, otherwise it
  %% fails. Without replacement means that no child can be selected twice
  %% until all children have been selected at least once.

  $template: true
  options: []
  min_children: 2

  execute: (task, wmem) => {
    let child_walk = wmem[this];

    if(typeof(child_walk) == "undefined" || child_walk.length == 0) {
      child_walk = Array.from(Array(task.childCount()).keys()).shuffle();
    }

    const child = child_walk.shift();
    wmem[this] = child_walk;

    return child.execute(wmem);
  }
end

@task ALWAYS begin
  %% The ALWAYS task takes one child and executes it, ALWAYS succeeds
  %% regardless of whether the child succeeds.

  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    const result = this.firstChild().execute(wmem);
    result.success = true;
    return result;
  }
end

@task NEVER begin
  %% The NEVER task takes one child and executes it, NEVER fails regardless
  %% of whether the child fails.

  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    const result = task.firstChild().execute(wmem);
    result.success = false;
    return result;
  }
end

@task INVERT begin
  %% The INVERT task takes one child and executes it. If the child succeeds
  %% then INVERT will fail. If the child fails then INVERT will succeed.

  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (task, wmem) => {
    const result = this.firstChild().execute(wmem);
    if(result.success) {
      result.success = false;
      result.error = "Inversion";
      result.id = task.id;
    } else {
      result.success = true;
    }
  }
end

@task FAIL begin
  %% The FAIL task automatically fails.

  $template: true
  options: []
  max_children: 0

  execute: (task, wmem) => {
    return {success: false, wmem: wmem};
  }
end

@task SUCCEED begin
  %% The SUCCEED task automatically succeeds.

  $template: true
  options: []
  max_children: 0

  execute: (task, wmem) => {
    return {success: true, wmem: wmem};
  }
end
