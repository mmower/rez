%% <% _ = assigns %>
%% Autogenerated with Rez v<%= Rez.version() %>
%% ** Do not modify as local changes will be overwritten every time the game is compiled **

%% ----------------------------------------------------------------------------
%% Defaults
%% ----------------------------------------------------------------------------

@defaults actor {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema actor {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  container_id: {kind: :elem_ref, ref_elem: @inventory}
  on_accept_item: {kind: :function, params: [actor event]}
  on_enter: {kind: :function, params: [actor event]}
  on_leave: {kind: :function, params: [actor event]}
  on_turn: {kind: :function, params: [actor event]}
  behaviours: {kind: :bht}
}

@defaults asset {
  $global: false
  $template: false
  $auto_id_idx: 0
  $js_runtime: false
  $js_defer: false
  $pre_runtime: false
  $inline: false
}

@schema asset {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :ref}
  $js_ctor: {kind: :set, coll_kind: :keyword}
  $js_runtime: {kind: :boolean}
  $js_defer: {kind: :boolean}
  $pre_runtime: {kind: :boolean}
  $inline: {kind: :boolean}

  tags: {kind: :set, coll_kind: :keyword}

  file_name: {kind: :string, xor: file_path}
  file_path: {kind: :string, xor: file_name, file_exists}
  width: {kind: [:string :number], and: height}
  height: {kind: [:string :number], and: width}
}

@defaults behaviour {
  $global: false
  $template: false
  $auto_id_idx: 0

  options: []
  min_children: 0
  max_children: 0
  owner_id: _
}

@schema behaviour {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  execute: {kind: :function, params: [behaviour], required: true}

  options: {kind: :list, coll_kind: :keyword}
  expected_keys: {kind: :list, coll_kind: :keyword}
  min_children: {kind: :number}
  max_children: {kind: :number}
  owner_id: {kind: :elem_ref}
}

@defaults card {
  $global: false
  $template: false
  $auto_id_idx: 0
  $flipped: false
  $suppress_wrapper: false
}

@schema card {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  content: {kind: :source_template, required: true}
  flipped_content: {kind: :source_template}

  $flipped: {kind: :boolean}
  $suppress_wrapper: {kind: :boolean}

  bindings: {kind: :list, coll_kind: :list_binding}
  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}
  css_class: {kind: :string}

  on_start: {kind: :function}
  on_finish: {kind: :function}
  on_render: {kind: :function}
}

@defaults effect {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema effect {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  on_apply: {kind: :function}
  on_remove: {kind: :function}
}

@defaults faction {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema faction {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}
}

@schema filter {
  name: {kind: :string, required: true}
  impl: {kind: :function, required: true}
}

@defaults game {
  $global: true
  $scene_stack: []
  $flash_messages: []
  start_events: []

  current_scene_id: _
  layout: ```
  ${content}
  ```
}

@schema game {
  $global: {kind: :boolean}
  $template: {allowed: false}
  $js_ctor: {kind: :string}
  $scene_stack: {kind: :list}
  $flash_messages: {kind: :list}
  start_events: {kind: :list, coll_kind: :list_binding}

  tags: {kind: :set, coll_kind: :keyword}

  name: {kind: :string, required: true}
  title: {kind: :string, required: true}
  author: {kind: :string, required: true}
  author_email: {kind: :string}
  archive_format: {kind: :number, required: true}
  layout: {kind: :source_template, required: true, contains: "${content}"}
  initial_scene_id: {kind: :elem_ref, ref_elem: @scene, required: true}
  IFID: {kind: :string, required: true}

  current_scene_id: {kind: :elem_ref}

  bindings: {kind: :list, coll_kind: :list_binding}
  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}
  links: {kind: :list, coll_kind: :string}
  scripts: {kind: :list, coll_kind: :string}

  on_init: {kind: :function}
  on_start: {kind: :function}
  on_save: {kind: :function}
  on_load: {kind: :function}
}

@defaults generator {
  $global: false
  $template: false

  customize: (obj) => {return obj;}
}

@schema generator {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $init_after: {kind: :list, coll_kind: :elem_ref}

  tags: {kind: :set, coll_kind: :keyword}

  priority: {kind: :number, min: 1, max: 100, required: true}
  source: {kind: :elem_ref, required: true}
  copies: {kind: :number, min: 0}

  customize: {kind: :function}
}

@defaults group {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema group {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  type: {kind: :keyword, in: [:image, :audio, :video], required: true}
  include_tags: {kind: :set, coll_kind: :keyword, xor: exclude_tags}
  exclude_tags: {kind: :set, coll_kind: :keyword, xor: include_tags}
}

@defaults inventory {
  $global: false
  $template: false
  $auto_id_idx: 0

  apply_effects: true
}

@schema inventory {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  owner: {kind: :elem_ref}
  slots: {kind: :set, coll_kind: :elem_ref, ref_elem: @slot, required: true, min_length: 1}
  apply_effects: {kind: :boolean}

  on_insert: {kind: :function}
  on_remove: {kind: :function}

  ?/^initial_/: {kind: :list, coll_kind: :elem_ref}
}

%% In Rez v1.8 we remove @item as a basic element and make it an alias of
%% @card so that items can be used directly in rendering the interface. You
%% can set the current card to an item to have it render itself.

@elem item = card

@defaults item {
  $global: false
  $template: false
  $auto_id_idx: 0
  is_item: true
  type: :item
}

@schema item {
  %% This does not preserve the item validation that determines whether the
  %% type refers to an accept: for a slot
  type: {kind: :keyword, required: true, is_a: @slot/accepts}

  container: {kind: :elem_ref, ref_elem: @inventory}
  size: {kind: :number, min: 0}
  uses: {kind: :number, min: 0}
  effects: {kind: :list, coll_kind: :elem_ref, ref_elem: @effect}
  asset_id: {kind: :elem_ref, ref_elem: @asset}
}

@defaults list {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema list {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  includes: {kind: :list, coll_kind: :elem_ref, ref_elem: @list}
  values: {kind: :list}

  tags: {kind: :set, coll_kind: :keyword}
}

@defaults object {
  $global: false
  $template: false
  $auto_id_idx: 0
}

@schema object {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}
}

@schema patch {
  patch: {kind: :string, required: true}
  impl: {kind: :function, required: true}

  function: {kind: :string, xor: method}
  method: {kind: :string, xor: function}
}

@defaults plot {
  $global: false
  $template: false
  $auto_id_idx: 0

  stage: 0
  active: false
}

@schema plot {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  stage: {kind: :number}
  active: {kind: :boolean}

  stages: {kind: :number, min: 1, required: true}
  priority: {kind: :number, min: 1, max: 100, required: true}

  tags: {kind: :set, coll_kind: :keyword}

  on_begin: {kind: :function}
  on_tick: {kind: :function}
  on_complete: {kind: :function}
}

@defaults rel {
  $global: false
  $template: false
}

@schema rel {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  source_id: {kind: :ref, required: true}
  target_id: {kind: :ref, required: true}

  tags: {kind: :set, coll_kind: :keyword}
}

@defaults scene {
  $global: false
  $template: false
  $auto_id_idx: 0
  $running: false

  current_card_id: _
  last_card_id: _
  layout: ```
  ${content}
  ```
  layout_mode: :single
  layout_separator: ""
  layout_reverse: false
}

@schema scene {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}
  $running: {kind: :boolean}

  initial_card_id: {kind: :elem_ref, ref_elem: @card, required: true}
  current_card_id: {kind: :elem_ref}
  last_card_id: {kind: :elem_ref}

  tags: {kind: :set, coll_kind: :keyword}

  layout: {kind: :source_template, contains: "${content}"}
  layout_mode: {kind: :keyword, in: [:single :stack]}
  layout_separator: {kind: :string}
  layout_reverse: {kind: :boolean}
  bindings: {kind: :list, coll_kind: :list_binding}
  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}

  on_init: {kind: :function}
  on_start: {kind: :function}
  on_finish: {kind: :function}
  on_interrupt: {kind: :function}
  on_resume: {kind: :function}
  on_render: {kind: :function}
  on_start_card: {kind: :function}
  on_finish_card: {kind: :function}
}

@defaults slot {
  $global: false
  $template: false
  $auto_id_idx: 0

  apply_effects: true
}

@schema slot {
  $global: {kind: :boolean}
  $template: {kind: :boolean}
  $auto_id_idx: {kind: :number}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  accepts: {kind: :keyword, required: true, type_exists}
  accessor: {kind: :keyword, required: true}

  tags: {kind: :set, coll_kind: :keyword}

  name: {kind: :string}
  apply_effects: {kind: :boolean}

  capacity: {kind: :number, min: 0}

  on_insert: {kind: :function}
  on_remove: {kind: :function}
}

@defaults system {
  $global: true
}

@schema system {
  $global: {kind: :boolean}
  $template: {allowed: false}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  tags: {kind: :set, coll_kind: :keyword}

  enabled: {kind: :boolean, required: true}
  priority: {kind: :number, min: 0, required: true}

  before_event: {kind: :function, param_count: 3, or: after_event}
  after_event: {kind: :function, param_count: 3, or: before_event}
}

@defaults timer {
  $global: false
  $timer: ""

  auto_start: true
  repeats: true

  on_game_started: (timer) => {if(timer.auto_start) {timer.run();}; return {handled: true};}
  on_game_loaded: (timer) => {if(timer.auto_start) {timer.run();}; return {handled: true};}
}

@schema timer {
  $global: {kind: :boolean}
  $template: {allowed: false}
  $init_after: {kind: :list, coll_kind: :elem_ref}
  $js_ctor: {kind: :string}

  $timer: {kind: :string}

  interval: {kind: :number, min: 0, required: true}
  event: {kind: :keyword, required: true} %% Could we support 'default: timer.id' ?

  auto_start: {kind: :boolean}
  repeats: {kind: :boolean}
  count: {kind: :number, min: 1}

  on_game_started: {kind: :function}
  on_game_loaded: {kind: :function}
}

%% ----------------------------------------------------------------------------
%% Head Assets
%% ----------------------------------------------------------------------------

%% Moved these to the base_game template so that users can override

@asset _PLURALIZE_JS {
  $built_in: true
  file_name: "pluralize.js"
  $js_defer: false
  $pre_runtime: true
}

%% ----------------------------------------------------------------------------
%% JS Library Patches
%% ----------------------------------------------------------------------------

@script {
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && Object.prototype.toString.call(obj) === "[object Object]";
  }
}

@patch {
  $built_in: true
  patch: "Boolean"
  function: "rand"
  impl: function() {
    return Math.random() < 0.5 ? true : false;
  }
}

@patch {
  $built_in: true
  patch: "Object"
  method: "copy"
  impl: function() {
    const deepCopy = (value) => {
      if(value === null || value === undefined || typeof(value) !== 'object') {
        return value;
      } else if(typeof(value.copy) === 'function') {
        return value.copy();
      } else {
        return Object.copy.call(value);
      }
    };

    // Handle null or undefined
    if (this === null || typeof this === 'undefined') {
        return this;
    }

    if(this instanceof Set) {
      return new Set([...this].map(item => deepCopy(item)));
    }

    // Handle array
    if (Array.isArray(this)) {
      return this.map(item => deepCopy(item));
    }

    // Handle object
    if (typeof this === 'object') {
        // Use the same constructor as the original object to preserve prototype chain
        let copiedObj;

        try {
            // Try to create a new instance using the constructor
            copiedObj = new this.constructor();
        } catch (e) {
            // If constructor fails, fall back to creating object with same prototype
            copiedObj = Object.create(Object.getPrototypeOf(this));
        }

        // Copy all enumerable properties
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                copiedObj[key] = deepCopy(this[key]);
            }
        }

        // Copy non-enumerable properties
        Object.getOwnPropertyNames(this).forEach(key => {
            if (!copiedObj.hasOwnProperty(key)) {
                const descriptor = Object.getOwnPropertyDescriptor(this, key);
                if (descriptor) {
                    // For accessor properties (getters/setters), preserve them
                    if (descriptor.get || descriptor.set) {
                        Object.defineProperty(copiedObj, key, descriptor);
                    } else {
                        // For data properties, deep copy the value
                        Object.defineProperty(copiedObj, key, {
                            value: deepCopy(descriptor.value),
                            writable: descriptor.writable,
                            enumerable: descriptor.enumerable,
                            configurable: descriptor.configurable
                        });
                    }
                }
            }
        });

        // Copy symbol properties
        Object.getOwnPropertySymbols(this).forEach(sym => {
            const descriptor = Object.getOwnPropertyDescriptor(this, sym);
            if (descriptor) {
                // For accessor properties (getters/setters), preserve them
                if (descriptor.get || descriptor.set) {
                    Object.defineProperty(copiedObj, sym, descriptor);
                } else {
                    // For data properties, deep copy the value
                    Object.defineProperty(copiedObj, sym, {
                        value: deepCopy(descriptor.value),
                        writable: descriptor.writable,
                        enumerable: descriptor.enumerable,
                        configurable: descriptor.configurable
                    });
                }
            }
        });

        return copiedObj;
    }

    // Handle other primitive types (e.g., string, number, etc.)
    return this;
  }
}

@patch {
  $built_in: true
  patch: "Object"
  method: "objMap"
  impl: function(f) {
    const entries = Object.entries(this);
    const new_entries = entries.map(([k, v]) => [k, f(v, k)]);
    return Object.fromEntries(new_entries);
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "dqWrap"
  impl: function() {
    return `"${this}"`;
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "max"
  impl: function() {
    if(this.length === 0) {
      throw new Error("Cannot get the max of an empty array!");
    }

    return this.reduce((a, b) => Math.max(a, b));
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "min"
  impl: function() {
    if(this.length === 0) {
      throw new Error("Cannot get the min of an empty array!");
    }

    return this.reduce((a, b) => Math.min(a, b));
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "englishList"
  impl: function(amp) {
    let connector = "and";
    if(amp != undefined && amp) {
      connector = "&";
    }

    switch(this.length) {
      case 0:
        return "";

      case 1:
        return `${this[0]}`;

      case 2:
        return this.join(` ${connector} `);

      default:
        return this.slice(0, -1).join(", ") + `, ${connector} ` + this[this.length - 1];
    }
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "remove"
  impl: function(elem) {
    const idx = this.indexOf(elem);
    if(idx !== -1) {
      this.splice(idx, 1);
    }
    return this;
  }
}

@patch {
  $built_in: true
  %% Fisher-Yates Shuffle impl from: https://sebhastian.com/fisher-yates-shuffle-javascript/
  patch: "Array"
  method: "fyShuffle"
  impl: function() {
    let idx = this.length;
    while(--idx > 0) {
      const rand_idx = Math.floor(Math.random() * (idx+1));
      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];
    }
    return this;
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "randomElement"
  impl: function() {
    return this.at(Math.floor(Math.random() * this.length));
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "randomIndex"
  impl: function() {
    return Math.floor(Math.random() * this.length);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "frequencies"
  impl: function() {
    const freqs = new Map();
    for(const v of this) {
      let val = freqs.get(v);
      if(typeof(val) == "undefined") {
        val = 1;
      } else {
        val = val + 1;
      }
      freqs.set(v, val);
    }
    return freqs;
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "normalizePTable"
  impl: function() {
    const sum = this.reduce((sum, [value, freq]) => sum + freq, 0);

    let cumProbability = 0.0;
    return this.map(([value, freq]) => {
      cumProbability += freq/sum;
      return [value, cumProbability];
    });
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "sum"
  impl: function() {
    return this.reduce((a, b) => a+b, 0);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  function: "equals"
  impl: function(a, b) {
    return Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        a.every((val, index) => val === b[index]);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "startsWithSequence"
  impl: function(sequence) {
    return this.slice(0, sequence.length).every((value, index) => value === sequence[index]);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "to_pairs"
  impl: function() {
    let pairs = [];
    for(let i = 0; i < this.length; i += 2) {
      if(this[i + 1] !== undefined) {
        pairs.push([this[i], this[i + 1]]);
      }
    }
    return pairs;
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "take"
  impl: function(n) {
    if(this.length < n) {
      throw `Cannot take ${n} items from an array containing ${this.length} items!`;
    }

    return Math.range(1, n).map((_) => {return this.shift()});
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "refs"
  impl: function() {
    return this.map((id) => $(id));
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "ids"
  impl: function() {
    return this.map((obj) => obj.id);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  function: "nOf"
  impl: function(length, def_value) {
    if(typeof(def_value) === "function") {
      return Array.from({length: length}, def_value);
    } else {
      return Array.from({length: length}, () => def_value);
    }
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "sample"
  impl: function(percentage) {
    if (!Array.isArray(this) || this.length === 0 || percentage <= 0) {
      return []; // Return an empty array for invalid input
    }

    const sampleSize = Math.ceil(this.length * (percentage / 100));
    const result = [];
    const indicesUsed = new Set();

    while (result.length < sampleSize && indicesUsed.size < this.length) {
      const randomIndex = Math.floor(Math.random() * this.length);
      if (!indicesUsed.has(randomIndex)) {
        indicesUsed.add(randomIndex);
        result.push(this[randomIndex]);
      }
    }

    return result;
  }
}

@patch {
  $built_in: true
  patch: "Array"
  function: "zip"
  impl: function(ar1, ar2) {
    return ar1.map((value, idx) => [value, ar2[idx]]);
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "splitWith"
  impl: function(pred) {
    return this.reduce(
        (acc, item) => {
          acc[pred(item) ? 0 : 1].push(item);
          return acc;
        },
        [[], []]
      );
  }
}

@patch {
  $built_in: true
  patch: "Array"
  method: "pushWithLimit"
  impl: function(el, lim) {
    this.push(el);
    if(this.length > lim) {
      this.shift();
    }
    return this;
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "beginsWithConsonant"
  impl: function() {
    return /^[^aeiouAEIOU]/.test(this);
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "beginsWithVowel"
  impl: function() {
    return /^[aeiouAEIOU]/.test(string);
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "toTitleCase"
  impl: function() {
    return this.replace(/(^|\s)\S/g, l => l.toUpperCase());
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "possessive"
  impl: function() {
    if(this.endsWith("s")) {
      return this + "'";
    } else {
      return this + "'s";
    }
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "toCamelCase"
  impl: function() {
    return this.replace(/[_.-](\w|$)/g, function (_, x) {
	  	return x.toUpperCase();
	  });
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "toPascalCase"
  impl: function() {
    const camelCase = this.replace(/[_.-](\w|$)/g, function (_, x) {
	  	return x.toUpperCase();
	  });
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "toKebabCase"
  impl: function() {
    return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('-');
  }
}



@patch {
  $built_in: true
  patch: "String"
  method: "toSnakeCase"
  impl: function() {
      return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('_');
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "parseTime"
  impl: function() {
    const time_components = this.match( /(\d+)(?::(\d\d))?\s*(p?)/ );
    const hour_s = time_components[1];
    if(typeof(hour_s) == "undefined") {
      throw "Invalid time string (hour): '" + this + "'";
    }
    const hour = parseInt(hour_s);
    if(hour == NaN) {
      throw "Invalid time string (hour): '" + this + "'";
    }

    const mins_s = time_components[2];
    if(typeof(mins_s) == "undefined") {
      throw "Invalid time string (mins): '" + this + "'";
    }

    const mins = parseInt(mins_s);
    if(typeof(mins) == NaN) {
      throw "Invalid time string (mins): '" + this + "'";
    }

    return [hour, mins];
  }
}

@patch {
  $built_in: true
  patch: "String"
  function: "randomId"
  impl: function() {
    const rand = window.crypto.getRandomValues(new Uint32Array(1))[0];
    return rand.toString(16);
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "wrapWith"
  impl: function(prefix, suffix) {
    suffix = suffix ?? prefix;
    return `${prefix}${this}${suffix}`;
  }
}

@patch {
  $built_in: true
  patch: "String"
  method: "indefiniteArticle"
  impl: function() {
    return this.beginsWithConsonant() ? "a" : "an";
  }
}

%% Some helpful set functions from:
%% https://medium.com/@alvaro.saburido/set-theory-for-arrays-in-es6-eb2f20a61848
%% https://stackoverflow.com/a/31129384/7518

@patch {
  $built_in: true
  patch: "Set"
  method: "union"
  impl: function(otherSet) {
    return new Set([...this, ...otherSet]);
  }
}

@patch {
  $built_in: true
  patch: "Set"
  method: "intersection"
  impl: function(otherSet) {
    return new Set([...this].filter(x => otherSet.has(x)));
  }
}

@patch {
  $built_in: true
  patch: "Set"
  method: "difference"
  impl: function(otherSet) {
    return new Set([...this].filter(x => !otherSet.has(x)));
  }
}

@patch {
  $built_in: true
  patch: "Set"
  method: "equals"
  impl: function(otherSet) {
    return this.size === otherSet.size &&
    [...this].every((x) => otherSet.has(x));
  }
}

@patch {
  $built_in: true
  patch: "Set"
  method: "hasSubset"
  impl: function(otherSet) {
    return this.intersection(otherSet).equals(otherSet);
  }
}

@patch {
  $built_in: true
  patch: "Number"
  method: "ordinal"
  impl: function() {
    const lastDigit = this % 10;
    const secondLastDigit = Math.floor((this % 100) / 10);

    if (lastDigit === 1 && secondLastDigit !== 1) {
      return this + 'st';
    } else if (lastDigit === 2 && secondLastDigit !== 1) {
      return this + 'nd';
    } else if (lastDigit === 3 && secondLastDigit !== 1) {
      return this + 'rd';
    } else {
      return this + 'th';
    }
  }
}

@patch {
  $built_in: true
  %% https://stackoverflow.com/questions/7342957/how-do-you-round-to-1-decimal-place-in-javascript
  patch: "Number"
  method: "roundp"
  impl: function(precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(this * multiplier) / multiplier;
  }
}

@patch {
  $built_in: true
  patch: "Number"
  method: "cl_avg"
  impl: function(rounds) {
    rounds ??= 2;
    const f = Math.random() < 0.5 ? Math.ceil : Math.floor;
    return f(this/rounds);
  }
}

@patch {
  $built_in: true
  %% rounds a number to the nearest 0.5
  patch: "Number"
  method: "r2nh"
  impl: function() {
    return Math.round(this * 2) / 2;
  }
}

@patch {
  $built_in: true
  patch: "Number"
  method: "dist_round"
  impl: function() {
    return Math.dist_round(this);
  }
}

@patch {
  $built_in: true
  patch: "Number"
  method: "round_to_nearest"
  impl: function(n) {
    if(n === 0) {
      return this;
    } else {
      return Math.round(this / n) * n;
    }
  }
}

@patch {
  %% See Array.nOf() for creating arrays with n items
  $built_in: true
  patch: "Number"
  method: "times"
  impl: function(f) {
    for(let ix = 0; ix < this; ix++) {
      f(ix);
    }
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "perc"
  impl: function(p) {
    return Math.random() <= (p/100);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "div"
  impl: function(n, d) {
    return Math.floor(n/d);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "div_mod"
  impl: function(n, d) {
    const div = Math.floor(n/d);
    const mod = n % d;
    return [div, mod];
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "range"
  impl: function(from, to, step) {
    step ??= 1;

    if(from>to) {
      [from, to] = [to, from];
    }

    return Array.from(
      {length: (to-from)/step+1},
      (_, i) => from + (i * step));
  }
}

@patch {
  $built_in: true
  %% Because JS only gives us random numbers as floating point we sometimes
  %% end up having to round when we want an integer. The question is whether we round
  %% up or round down which can create a bias. The dist_round function randomly
  %% round up or down to distribute values evenly.
  patch: "Math"
  function: "dist_round"
  impl: function(v) {
    if(Math.random() < 0.5) {
      return Math.ceil(v);
    } else {
      return Math.floor(v);
    }
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "rand_int"
  impl: function(lim) {
    return Math.floor(Math.random() * lim);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "rand_int_between"
  impl: function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }
    return Math.floor(min + Math.random() * (max - min + 1));
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "rand_f_between"
  impl: function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }

    return min + (Math.random() * (max - min));
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "cl_rand_f_between"
  impl: function(min, max, rounds) {
    rounds = rounds ?? 2;
    let total = 0;
    for(let i = 0; i < rounds; i+= 1) {
      total += Math.rand_f_between(min, max);
    }
    return total/rounds;
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "cl_rand_int"
  impl: function(lim) {
    const v1 = Math.rand_int(lim);
    const v2 = Math.rand_int(lim);
    return (v1+v2)/2;
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "cl_rand_int_between"
  impl: function(lo, hi) {
    const v1 = Math.rand_int_between(lo, hi);
    const v2 = Math.rand_int_between(lo, hi);
    return Math.dist_round((v1+v2)/2);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "clamped_sub"
  impl: function(value, sub, min) {
    return Math.max(value-sub, min);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "clamped_add"
  impl: function(value, add, max) {
    return Math.min(value+add, max);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "alter"
  impl: function(value, change, min, max) {
    return Math.max(Math.min(value+change, max), min);
  }
}

@patch {
  $built_in: true
  patch: "Math"
  function: "samplePTable"
  impl: function(table) {
    if(!Array.isArray(table)) {
      throw new Error(`Tried to sample an ${typeof(table)} which is expected be an array [[value, prob], [value, prob], ...]`);
    }

    const p = Math.random();
    const idx = table.findIndex((pair) => p <= pair[1]);
    if (idx == -1) {
      throw new Error("Invalid p_table. Must contain range 0<n<1");
    }
    return table[idx][0];
  }
}

%% ----------------------------------------------------------------------------
%% Template Filters
%% ----------------------------------------------------------------------------

@filter COMPARE_EQ_FILTER {
  $built_in: true

  %% v -> v -> bool
  name: "eq"
  impl: (v1, v2) => {return v1 === v2;}
}

@filter COMPARE_NE_FILTER {
  $built_in: true

  %% v -> v -> bool
  name: "ne"
  impl: (v1, v2) => {return !(v1 === v2);}
}

@filter COMPARE_GT_FILTER {
  $built_in: true

  %% n -> n -> bool
  name: "gt"
  impl: (n1, n2) => {return n1 > n2;}
}

@filter COMPARE_GTE_FILTER {
  $built_in: true

  %% n -> n -> bool
  name: "gte"
  impl: (n1, n2) => {return n1 >= n2;}
}

@filter COMPARE_LT_FILTER {
  $built_in: true

  %% n -> n -> bool
  name: "lt"
  impl: (n1, n2) => {return n1 < n2;}
}

@filter COMPARE_LTE_FILTER {
  $built_in: true

  %% n -> n -> bool
  name: "lte"
  impl: (n1, n2) => {return n1 <= n2;}
}

@filter BSEL_FILTER {
  $built_in: true

  %% bool -> array -> any
  name: "bsel"
  impl: (sel, options) => {return options[sel ? 0 : 1];}
}

@filter SEL_FILTER {
  $built_in: true

  %% n -> array -> any
  name: "sel"
  impl: (idx, options) => {return options[idx];}
}

@filter ADD_FILTER {
  $built_in: true

  %% n -> n
  name: "add"
  impl: (n, x) => {return n+x;}
}

@filter SUB_FILTER {
  $built_in: true

  %% n -> n
  name: "sub"
  impl: (n, x) => {return n-x;}
}

@filter MUL_FILTER {
  $built_in: true

  %% n -> n
  name: "mul"
  impl: (n, x) => {return n*x;}
}

@filter DIV_FILTER {
  $built_in: true

  %% n -> n
  name: "div"
  impl: (n, x) => {return n/x;}
}

@filter MOD_FILTER {
  $built_in: true

  %% n -> n
  name: "mod"
  impl: (n, x) => {return n % x;}
}

@filter ABS_FILTER {
  $built_in: true

  %% n -> n
  name: "abs"
  impl: (n) => {return Math.abs(n)}
}

@filter NEG_FILTER {
  $built_in: true

  %% n -> n
  name: "neg"
  impl: (n) => {return -n;}
}

@filter INC_FILTER {
  $built_in: true

  %% n -> n
  name: "inc"
  impl: (n) => {return n+1;}
}

@filter DEC_FILTER {
  $built_in: true

  %% n -> n
  name: "dec"
  impl: (n) => {return n-1;}
}

@filter ROUND_FILTER {
  $built_in: true

  %% n -> n
  name: "round"
  impl: (n, dp) => {return n.roundp(dp);}
}

@filter LPAD_FILTER {
  $built_in: true

  %% n, p, c -> "(m*s)n"
  name: "lpad"
  impl: (n, padChar, length) => {
    return String(n).padStart(length, padChar);
  }
}

@filter RPAD_FILTER {
  $built_in: true

  name: "rpad"
  impl: (n, padChar, length) => {
    return String(n).padEnd(length, padChar);
  }
}

@filter ORDINAL_FILTER {
  $built_in: true

  %% n -> "n(st|nd|rd|th)"
  name: "ordinal"
  impl: (n) => {return n.ordinal();}
}

@filter STRING_CHAR_AT_FILTER {
  $built_in: true

  %% String -> String
  name: "char_at"
  impl: (s, i) => {return s.charAt(i);}
}

@filter STRING_MAKE_FILTER {
  $built_in: true

  %% any -> String
  name: "string"
  impl: (s) => {return ""+s;}
}

@filter STRING_APPEND_FILTER {
  $built_in: true

  %% String -> String
  name: "append"
  impl: (s, t) => {return s + t;}
}

@filter STRING_TO_CAMEL_CASE_FILTER {
  $built_in: true

  %% String -> String
  name: "to_camel_case"
  impl: (s) => {return s.toCamelCase();}
}

@filter STRING_TRIM_FILTER {
  $built_in: true

  %% String -> String
  %% ${"  Foo  " | trim} = "foo"
  name: "trim"
  impl: (s) => {return s.trim();}
}

@filter STRING_TO_TITLE_CASE_FILTER {
  $built_in: true

  %% String -> String
  name: "to_title_case"
  impl: (s) => {return s.toTitleCase();}
}

@filter STRING_DOWNCASE_FILTER {
  $built_in: true

  %% String -> String
  name: "downcase"
  impl: (s) => {return s.toLowerCase();}
}

@filter STRING_PREPEND_FILTER {
  $built_in: true

  %% String -> String
  name: "prepend"
  impl: (s, t) => {return t + s;}
}

@filter STRING_UPCASE_FILTER {
  $built_in: true

  %% String -> String
  name: "upcase"
  impl: (s) => {return s.toUpperCase();}
}

@filter STRING_PLURALIZE_FILTER {
  $built_in: true

  %% String -> String
  name: "pluralize"
  impl: (s) => {return pluralize(s);}
}

@filter STRING_POSSESSIVE_FILTER {
  $built_in: true

  %% String -> String
  name: "possessive"
  impl: (s) => {return s.possessive();}
}

@filter STRING_SPLIT_FILTER {
  $built_in: true

  %% String -> Array
  name: "split"
  impl: (s, p) => {return s.split(p);}
}

@filter STRING_STARTS_WITH_FILTER {
  $built_in: true

  %% String -> Bool
  name: "starts_with"
  impl: (s, search) => {return s.startsWith(search);}
}

@filter STRING_ENDS_WITH_FILTER {
  $built_in: true

  %% String -> Bool
  name: "ends_with"
  impl: (s, search) => {return s.endsWith(search);}
}

@filter STRING_CONTAINS_FILTER {
  $built_in: true

  %% String -> Bool
  name: "contains"
  impl: (s, search) => {return s.includes(search);}
}

@filter STRING_QUOTED_FILTER {
  $built_in: true

  %% String -> String
  name: "quoted"
  impl: (s) => {return `'${s}'`;}
}

@filter STRING_DOUBLE_QUOTED_FILTER {
  $built_in: true

  %% String -> String
  name: "dquoted"
  impl: (s) => {return `"${s}"`;}
}

@filter STRING_INDEFINITE_ARTICLE_FILTER {
  $built_in: true

  %% String -> String
  name: "i_article"
  impl: (s) => {
    const article = s.indefiniteArticle();
    return `${article} ${s}`;
  }
}

@filter ARRAY_LENGTH_FILTER {
  $built_in: true

  %% Array -> Integer
  name: "length"
  impl: (arr) => {return arr.length;}
}

@filter ARRAY_TAKE_FILTER {
  $built_in: true

  %% Array, n -> Array
  name: "take"
  impl: (arr, n) => {return arr.take(n);}
}

@filter ARRAY_AT_FILTER {
  $built_in: true

  %% Array, n -> value
  name: "at"
  impl: (arr, n) => {return arr[n];}
}

%% Most of the following filters have been superceded either by the revised
%% link syntax, or components.

@filter EVENT_LINK_FILTER {
  $built_in: true

  %% String -> Link
  %% ${<Title> | event: <event-id>}
  %% ${"Go here" | event: "fudge"}

  name: "event"
  impl: (event, title) => {
    return "<a href='javascript:void(0);' class='event' data-event='" + event + "'>" + title + "</a>";
  }
}

@filter DYN_LINK_FILTER {
  $built_in: true

  %% ${card | dyn_link: <action>}
  %% ${card | dyn_link: "can_attack"}
  name: "dyn_link"
  impl: (card, action) => {
    const link_handler = card.getAttribute(action);
    if(typeof(link_handler) != "function") {
      throw `Attribute |${action}| of card |${card.id}| is not a handler function!`;
    } else {
      let link = new RezDynamicLink(card);
      link_handler(link);
      if(!link.choosen) {
        throw new Error("Choice must call one of hide/deny/allow!");
      }
      if(link.display) {
        return link.markup;
      } else {
        return "";
      }
    }
  }
}

@filter RENDER {
  $built_in: true

  %% Template, View -> String

  %% The render filter bends the renderer to allow inline rendering of templates
  %% it depends upon the $block binding that makes the view available to rendering
  %% blocks. You pass (template, $block) and it will treat the template as a block
  %% with the current block as parents (ergo all parent bindings are available
  %% to the rendering block).

  name: "render"
  impl: (source_obj, attribute, parent_block) => {
    const template = source_obj.getAttribute(attribute);
    if(typeof(template) === "undefined") {
      throw `Unable to render ${attribute} of ${source_obj.id} as it is not defined`;
    } else if(typeof(template) === "string") {
      return template;
    } else {
      const render_source = new RezSyntheticSource(template);
      const sub_block = new RezBlock("block", render_source);
      sub_block.parent_block = parent_block;
      return sub_block.renderBlock();
    }
  }
}

%% ----------------------------------------------------------------------------
%% Useful components
%% ----------------------------------------------------------------------------

@component embed_card (bindings, assigns, content) => {
  let blockSource;
  if(typeof(assigns.card) === "string") {
    // We expect the id of a card
    blockSource = $t(assigns.card, "card", true);
  } else if(typeof(assigns.card) === "object" && assigns.card instanceof RezCard) {
    // Otherwise it should be a reference to a card
    blockSource = assigns.card;
  } else {
    throw new Error(`Attempt to embed card with bad 'card' assign! (${typeof(assigns.card)})`);
  }
  blockSource.$parent = bindings.card;
  const block = new RezBlock("block", blockSource);
  block.parentBlock = bindings.card.parentBlock;
  return block.html();
}

@component img (bindings, assigns, content) => {
  const asset = $(assigns["name"]);
  const path = asset.$dist_path;

  // Use assigns width/height if provided, otherwise use asset dimensions
  const w = assigns["width"] || asset.width;
  const h = assigns["height"] || asset.height;

  // Extract name, width and height from assigns so we don't duplicate them
  const { name, width, height, ...otherAssigns } = assigns;

  // Build additional attributes string from remaining assigns
  const otherAttributes = Object.entries(otherAssigns)
    .map(([key, value]) => `${key}="${value}"`)
    .join(" ");

  return `<img src="${path}" width="${w}" height="${h}" ${otherAttributes} />`;
}

%% ----------------------------------------------------------------------------
%% A scene that handles loading a game
%% ----------------------------------------------------------------------------

@scene $load_game {
  $built_in: true

  initial_card_id: #$load_game_form
  layout: ```
  ${content}
  ```
  layout_mode: :single
}

@card $load_game_form {
  $built_in: true

  content: ```
  <form rez-live name="load_form">
    <input type="file" name="data"/>
    <input type="submit"/>
  </form>
  ```

  on_load_form: (card, data) => {
    console.log("In the load form handler!");
    const form = data.form;
    const file_input = form.querySelector("input[type=file]");
    const [file] = file_input.files;
    const reader = new FileReader();
    reader.addEventListener("load", function() {
      $game.load(reader.result);
    });
    reader.readAsText(file);
    return RezEvent.noop();
  }
}

%% ----------------------------------------------------------------------------
%% Default Behaviour Conditions & Actions
%% ----------------------------------------------------------------------------

@system $actor_behaviours {
  $built_in: true

  enabled: false
  priority: 10
  after_event: (system, evt, result) => {
    if(evt.target.dataset.event === "behaviours") {
      console.log("Running actor_behaviours system");
      const game = evt.game;
      const actors = game.getAll("actor").filter((actor) => {return actor.hasAttribute("behaviours")});
      actors.forEach((actor) => {
        const btree = actor.getAttributeValue("behaviours");
        btree.executeBehaviour();
      });
    }
    return result;
  }
}

%% Core behaviours
%% These behaviours model the 'generic' behaviours implemented in the
%% Crysis engine:
%% https://docs.cryengine.com/display/CEPROG/Modular+Behavior+Tree+Nodes
%% See the Behaviour Tree part of the user guide for more information.
%%
%% Core behaviours use an id beginning with a dollar to avoid conflict
%% with author generated id's.

@behaviour $select {
  %% The $select behaviour executes it's children in turn until one of them
  %% succeeds, then $select succeeds. If no child succeeeds then $select fails.

  $built_in: true
  $template: true
  options: []
  min_children: 2

  execute: (behaviour) => {
    for(const child of behaviour.children) {
      if(child.executeBehaviour()) {
        return true;
      }
    }
    return false;
  }
}

@behaviour $select_r {
  %% The $select_r behaviour is similar to $select except that each time it
  %% executes, it executes its children in random order.

  $built_in: true
  $template: true
  options: []
  min_children: 2

  execute: (behaviour) => {
    const indices = Math.range(0, behaviour.childCount-1).fy_shuffle();
    for(const i of indices) {
      const child = behaviour.getChildAt(i);
      if(child.executeBehaviour()) {
        return true;
      }
    }
    return false;
  }
}

@behaviour $select_p {
  %% The $select_p behaviour is similar to SELECT except that before ticking any
  %% child it does a probability check using the "p" option. If the check passes
  %% it ticks the child, otherwise it moves on to the next child. If a child
  %% succeeds $select_p succeeds. If no child succeeds, $select_p fails.

  $built_in: true
  $template: true
  options: [:p]
  min_children: 2

  configure: (behaviour) => {
    const p = behaviour.intOption("p");
    if(p < 0 || p > 100) {
      throw "Behaviour: " + behaviour.id + " invalid 'p' option specified.";
    }
  }

  execute: (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);
    for(const child of behaviour.children) {
      if(die.roll() < p) {
        if(child.executeBehaviour()) {
          return true;
        }
      }
    }
    return false;
  }
}

@behaviour $sequence {
  %% The $sequence behaviour executes its children in turn. If they all succeed
  %% then the $sequence succeeds. If a child fails the $sequence fails and does
  %% not execute any further children.

  $built_in: true
  $template: true
  options: []
  min_children: 2

  execute: (behaviour) => {
    for(const child of behaviour.children) {
      if(!child.executeBehaviour()) {
        return false;
      }
    }
    return true;
  }
}

@behaviour $loop {
  %% The $loop behaviour takes one child and executes it 'count' times. If it
  %% succeeds on every repetition the $loop succeeds. If the child ever fails
  %% the $loop fails.

  $built_in: true
  $template: true
  options: [:count]
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    const count = behaviour.intOption("count");
    for(let i=0; i<count; i++) {
      if(!behaviour.firstChild.executeBehaviour()) {
        return false;
      }
    }
    return true;
  }
}

@behaviour $loop_until {
  %% The $loop_until behaviour takes one child and executes it until it
  %% succeeds. The 'attempts' option specifies how many times it will
  %% executed. If the child ever succeeds, $loop_until succeeds. If the
  %% child doesn't succeed in the number of attempts then $loop_until fails.

  $built_in: true
  $template: true
  options: [:attempts]
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    const attempts = behaviour.intOption("attempts");
    for(let i=0; i<attempts; i++) {
      if(behaviour.firstChild.executeBehaviour()) {
        return true;
      }
    }
    return false;
  }
}

@behaviour $maybe {
  %% The $maybe behaviour takes one child and based on the option "p" determines
  %% whether to execute it or not. If it executes the child then $maybe succeeds
  %% if the child succeeds or fails if the child fails. If it doesn't execute
  %% the child then $maybe fails.

  $built_in: true
  $template: true
  options: [:p]
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);

    if(die.roll() < p) {
      return behaviour.firstChild.executeBehaviour();
    } else {
      return false;
    }
  }
}

@behaviour $either {
  %% The $either behaviour takes two children and based on the probability
  %% option "p" determines whether to execute the first or second child.
  %% Having decided which child to execute $either succeeds or fails based
  %% on whether the selected child succeeds or fails.

  $built_in: true
  $template: true
  options: [:p]
  min_children: 2
  max_children: 2

  execute: (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);
    const roll = die.roll();

    if(roll < p) {
      return behaviour.firstChild.executeBehaviour();
    } else {
      return behaviour.secondChild.executeBehaviour();
    }
  }
}

@behaviour $random_choice {
  %% The $random_choice behaviour takes two or more children. When $random_choice
  %% executes it selects a child at random and executes it. If that child
  %% succeeds then $random_choice succeeds, otherwise it fails.

  $built_in: true
  $template: true
  options: []
  min_children: 2

  execute: (behaviour) => {
    const die = new RezDie(1, behaviour.childCount, -1);
    const child = behaviour.getChildAt(die.roll());
    return child.executeBehaviour();
  }
}

@behaviour $random_each {
  %% The $random_each behaviour takes two or more children. When $random_each
  %% executes it selects a child, without replacement, and executes it. If
  %% the selected child succeeds then $random_each succeeds, otherwise it
  %% fails. Without replacement means that no child can be selected twice
  %% until all children have been selected at least once.

  $built_in: true
  $template: true
  options: []
  min_children: 2

  execute: (behaviour) => {
    const stateKey = `behavior_${behaviour.id}_state`;
    let child_walk = behaviour.owner.getAttribute(stateKey);

    if(typeof(child_walk) == "undefined" || child_walk.length == 0) {
      child_walk = Array.from(Array(behaviour.childCount).keys()).fy_shuffle();
    }

    const child_idx = child_walk.shift();
    behaviour.owner.setAttribute(stateKey, child_walk);

    const child = behaviour.getChildAt(child_idx);
    return child.executeBehaviour();
  }
}

@behaviour $always {
  %% The $always behaviour takes one child and executes it, $always succeeds
  %% regardless of whether the child succeeds.

  $built_in: true
  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    behaviour.firstChild.executeBehaviour();
    return true;
  }
}

@behaviour $never {
  %% The $never behaviour takes one child and executes it, $never fails regardless
  %% of whether the child fails.

  $built_in: true
  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    behaviour.firstChild.executeBehaviour();
    return false;
  }
}

@behaviour $invert {
  %% The $invert behaviour takes one child and executes it. If the child succeeds
  %% then $invert will fail. If the child fails then $invert will succeed.

  $built_in: true
  $template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour) => {
    return !behaviour.firstChild.executeBehaviour();
  }
}

@behaviour $fail {
  %% The $fail behaviour automatically fails.

  $built_in: true
  $template: true
  options: []
  max_children: 0

  execute: (behaviour) => {
    return false;
  }
}

@behaviour $succeed {
  %% The $succeed behaviour automatically succeeds.

  $built_in: true
  $template: true
  options: []
  max_children: 0

  execute: (behaviour) => {
    return true;
  }
}
