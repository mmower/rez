// Auto-generated by Rez v<%= Rez.version %>
// Do not modify as it will be overwritten when the game is next compiled.
<% import Rez.AST.ValueEncoder, only: [encode_attributes: 1, encode_function: 1] %>
<% import Rez.AST.NodeHelper, only: [get_attr_value: 2] %>
<% alias Rez.AST.Asset %>

(function() {
  "use strict";

window.Rez = window.Rez ?? {};

function randomId() {
  const rand = window.crypto.getRandomValues(new Uint32Array(1))[0];
  return rand.toString(16);
}

window.Rez.randomId = randomId;

function range(from, to = 1) {
  if(from>to) {
    return range(to, from);
  }

  const vals = [];
  for(let i = from; i<=to; i++) {
    vals.push(i);
  }

  return vals;
}

window.Rez.range = range;

//-----------------------------------------------------------------------------
// Additions to JS stdlib
//-----------------------------------------------------------------------------

Object.defineProperty(Object.prototype, "copy", {
  value: function() {
    const copy = {};
    for(const property in this) {
      let value = this[property];
      if(typeof(value) == "object") {
        copy[property] = value.copy();
      } else {
        copy[property] = value;
      }
    }
    return copy;
  }
});

Object.defineProperty(Object.prototype, "obj_map", {
  value: function(f) {
    const entries = Object.entries(this);
    const new_entries = entries.map(([k, v]) => [k, f(v)]);
    return Object.fromEntries(new_entries);
  }
});

/*
 * Fisher-Yates Shuffle impl from: https://sebhastian.com/fisher-yates-shuffle-javascript/
 */
Object.defineProperty(Array.prototype, "fy_shuffle", {
  value: function() {
    let idx = this.length;
    while(--idx > 0) {
      const rand_idx = Math.floor(Math.random() * (idx+1));
      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];
    }
    return this;
  }
});

Object.defineProperty(Array.prototype, "randomElement", {
  value: function() {
    return this.at(Math.floor(Math.random() * this.length));
  }
});

Object.defineProperty(Array.prototype, "randomIndex", {
  value: function() {
    return Math.floor(Math.random() * this.length);
  }
});

Object.defineProperty(Array.prototype, "frequencies", {
  value: function() {
    const freqs = new Map();
    for(const v of this) {
      let val = freqs.get(v);
      if(typeof(val) == "undefined") {
        val = 1;
      } else {
        val = val + 1;
      }
      freqs.set(v, val);
    }
    return freqs;
  }
});

Object.defineProperty(String.prototype, "interpolate", {
  value: function(game) {
    return this;
  }
});

Object.defineProperty(String.prototype, "toSnakeCase", {
  value: function() {
      return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('_');
  }
});

// Some helpful set functions from:
// https://medium.com/@alvaro.saburido/set-theory-for-arrays-in-es6-eb2f20a61848
// https://stackoverflow.com/a/31129384/7518

Object.defineProperty(Set.prototype, "union", {
  value: function(otherSet) {
    return new Set([...this, ...otherSet]);
  }
});

Object.defineProperty(Set.prototype, "intersection", {
  value: function(otherSet) {
    return new Set([...this].filter(x => otherSet.has(x)));
  }
});

Object.defineProperty(Set.prototype, "difference", {
  value: function(otherSet) {
    return new Set([...this].filter(x => !otherSet.has(x)));
  }
});

Object.defineProperty(Set.prototype, "equals", {
  value: function(otherSet) {
    return this.size === otherSet.size &&
    [...this].every((x) => otherSet.has(x));
  }
});

Object.defineProperty(Set.prototype, "hasSubset", {
  value: function(otherSet) {
    return this.intersection(otherSet).equals(otherSet);
  }
});

//-----------------------------------------------------------------------------
// Register Handlebars Helpers
//-----------------------------------------------------------------------------

<%= for {_id, helper} <- @game.helpers do %>
  <% name = get_attr_value(helper, "name") %>
  <% handler = get_attr_value(helper, "handler") %>
  Handlebars.registerHelper("<%= name %>", <%= encode_function(handler) %>);
<% end %>

<%= @view_code %>

//-----------------------------------------------------------------------------
// Basic Object Prototype
//-----------------------------------------------------------------------------

/*
  Basic Object

  The basic_object is the common prototype of all in-game objects.

  It keeps a reference to the singleton Game object allowing that to be looked
  up from any other object.

  It handles getting attribute values.

  It handles execution of named event handler.
*/

let basic_object = {
  game: null,
  initialised: false,

  /*
   * Object ref lookup shortcut
  */
  $(id) {
    return this.game.getGameObject(id);
  },

  /*
   * Intialization
  */

  init() {
    if(!this.initialised) {
      console.log("Initialise " + this.id);
      this.initRefAttributes();
      this.elementInitializer();
      this.runEvent("init", {});
      this.initialised = true;
    }
  },

  initRefAttributes() {
    for(let attr_name of Object.keys(this.attributes)) {
      const value = this.getAttribute(attr_name);

      // We're looking for {ref: "attr_name"}
      if(typeof(value) == "object") {
        const ref_name = value["attr_ref"];
        if(typeof(ref_name) == "string") {
          this.initRefAttribute(attr_name, ref_name);
        }
      }
    }
  },

  elementInitializer() {
  },

  refAttrValue(ref_name) {
    const attr = this.getAttribute(ref_name);
    if(typeof(attr) == "undefined") {
      console.log("Ref '" + ref_name + "' does not point at a valid attribute");
      return null;
    } else {
      if(typeof(attr) == "function") {
        return attr(this.game, this);
      } else if(attr.constructor == RezDie) {
        return attr.roll();
      } else {
        console.log("Ref '" + ref_name + "' does not point to a valid type of attribute");
        return null;
      }
    }
  },

  initRefAttribute(attr_name, ref_name) {
    const value = this.refAttrValue(ref_name);
    if(value != null) {
      this.setAttribute(attr_name, value);
    }
  },

  /*
   * Template object copying
  */

  copyAssigningId(id) {
    const attributes = this.attributes.copy();
    const copy = new this.constructor(id, attributes);
    copy.runEvent("copy", {original: this});
    //copy.setAttribute("template", false);
    copy.setAttribute("copy_of", this.id);
    copy.init();
    return copy;
  },

  // Need to check if there is a problem with copying copies
  // and ID auto-assignment. Shouldn't be, we should get
  // <id>_1_1, <id>_1_1_1 and so on but should be tested.
  copyWithAutoId() {
    this.auto_id_idx += 1;
    const copy_id = this.id + "_" + this.auto_id_idx;
    return this.copyAssigningId(copy_id);
  },

  /*
   * Event Handling
  */

  eventHandler(event_name) {
    return this.attributes["on_" + event_name];
  },

  willHandleEvent(event_name) {
    const handler = this.eventHandler(event_name);
    const does_handle_event = handler != null && typeof(handler) == "function";
    return does_handle_event;
  },

  runEvent(event_name, event_info) {
    console.log("Run on_" + event_name + " handler on " + this.id);
    let handler = this.eventHandler(event_name);
    if(handler != null && typeof(handler) == "function") {
      return handler(this, event_info);
    } else {
      return false;
    }
  },

  /*
   * Attribute query/get/set
  */

  getIn(path) {
    const segments = path.split(".");
    const first = segments[0];
    const rest = segments.slice(1);
    const value = this.attributes[first];

    if(null == value) {
      return null;
    } else {
      return rest.reduce((attr, segment) => {
        let next_value = attr[segment];
        if(typeof(next_value) == "undefined") {
          return null;
        } else {
          return next_value;
        }
      }, value);
    }
  },

  hasAttribute(name) {
    return !!this.attributes[name];
  },

  getAttribute(name) {
    const attr = this.attributes[name];
    return attr;
  },

  getAttributeValue(name, default_value) {
    const attr = this.getAttribute(name);
    if(typeof(attr) == "undefined") {
      if(typeof(default_value) == "undefined") {
        throw "Attempt to get value of attribute |" + name + "| which is not defined on |#" + this.id + "|";
      } else {
        return default_value;
      }
    } else if(typeof(attr) == "function") {
      return attr(this);
    } else if(attr.constructor == RezDie) {
      return attr.roll();
    } else {
      return attr;
    }
  },

  getObjectViaAttribute(name, default_value) {
    const id = this.getAttributeValue(name, default_value);
    return $(id);
  },

  setObjectViaAttribute(name, object) {
    this.setAttribute(name, object.id);
  },

  attributeHasChanged(attr_name) {
    this.changed_attributes.push(attr_name);
  },

  setAttribute(name, value) {
    if(typeof(value) == "undefined") {
      throw "Call to setAttribute with undefined value!";
    }
    this.attributes[name] = value;
    this.attributeHasChanged(name);
  },

  addTag(tag) {
    let tags = this.getAttribute("tags");
    if(!tags) {
      tags = new Set([tag]);
    } else {
      tags.add(tag);
    }

    this.setAttribute("tags", tags);
    this.game.indexObjectForTag(this, tag);
  },

  removeTag(tag) {
    let tags = this.getAttribute("tags");
    if(!tags) {
      tags = new Set();
    } else {
      tags.delete(tag);
    }

    this.setAttribute("tags", tags);
    this.game.unindexObjectForTag(this, tag);
  },

  setTags(new_tags) {
    new_tags = new Set(new_tags); // Just in case they are passed as an array
    const old_tags = this.getAttributeValue("tags", new Set());

    const to_remove = old_tags.difference(new_tags);
    to_remove.forEach((tag) => this.removeTag(tag));

    const to_add = new_tags.difference(old_tags);
    to_add.forEach((tag) => this.addTag(tag));
  },

  putIn(path, value) {
    const selectors = path.split(".");
    const first_selector = selectors[0];
    if(selectors.length == 1) {
      this.setAttribute(first_selector, value);
    } else {
      const lookup_selectors = selectors.slice(1, -1);
      let target = lookup_selectors.reduce((target, selector) => {
        return target[selector];
      }, this.getAttribute(first_selector));

      if(typeof(target) == "undefined") {
        throw "Attempt to putIn invalid path: " + path + " on " + this.id;
      } else {
        const final_selector = selectors.slice(-1);
        target[final_selector] = value;
        this.changedAttribute(first_selector);
      }
    }

    return this;
  },

  incAttribute(name, amount = 1) {
    let value = this.getAttribute(name);
    if(typeof(value) == "number") {
      this.setAttribute(name, value+amount);
    } else {
      throw "Attempt to inc/dec non-numeric attribute: " + name;
    }
  },

  decAttribute(name, amount = 1) {
    this.incAttribute(name, -amount);
  },

  /*
   * Effect Management
   */
  applyEffect(effect_id, item_id) {
    console.log("Been asked to apply effect |"+effect_id+"| from item |"+item_id+"| to |"+this.id+"|");
  },

  removeEffect(effect_id, item_id) {
    console.log("Been asked to remove effect |"+effect_id+"| from item |"+item_id+"| to |"+this.id+"|");
  },

  /*
   * Binding
  */

  addBinding(name, object) {
    const bindings = this.getAttribute("bindings") || {};
    bindings[name] = object.id;
    this.setAttribute("bindings", bindings);
  },

  /*
   * Archiving
  */

  needsArchiving() {
    return this.changed_attributes.length > 0 || this.properties_to_archive.length > 0;
  },

  archiveDataContainer() {
    return {
      id: this.id,
      type: this.game_object_type
    };
  },

  dataWithArchivedAttributes(data) {
    const obj= this;
    return this.changed_attributes.reduce(
      function(data, key) {
        data["attrs"] = data["attrs"] || {};
        data["attrs"][key] = obj.getAttribute(key)
        return data;
      },
      data
    );
  },

  dataWithArchivedProperties(data) {
    const obj = this;
    return this.properties_to_archive.reduce(
      function(data, key) {
        data["props"] = data["props"] || {};
        data["props"][key] = obj[key];
        return data;
      },
      data
    );
  },

  toJSON() {
    let data = this.archiveDataContainer();
    data = this.dataWithArchivedProperties(data);
    data = this.dataWithArchivedAttributes(data);
    return data;
  },

  loadData(data) {
    const attrs = data["attrs"];
    if(typeof(attrs) == "object") {
      for(const [k, v] of Object.entries(attrs)) {
        this.setAttribute(k, v);
      }
    }

    const props = data["props"];
    if(typeof(props) == "object") {
      for(const [k, v] of Object.entries(props)) {
        this[k] = v;
      }
    }
  }
};

Object.defineProperty(Object.prototype, "isGameObject", {
  value: function() {
      return basic_object.isPrototypeOf(this);
  }
});

//-----------------------------------------------------------------------------
// Actor
//-----------------------------------------------------------------------------

let actor_proto = {
  __proto__: basic_object,

  /*
   * Give the actor an opportunity to respond to an on_accept_item callback
   * and return a RezDecision with the result. By default items are accepted.
   */
  checkItem(inventory_id, slot_id, item_id) {
    const decision = new RezDecision("Filter Item");
    decision.default_yes();
    if(this.willHandleEvent("accept_item")) {
      this.runEvent(
        "accept_item", {
          decision: decision,
          inventory_id: inventory_id,
          item_id: item_id
        });
    }
    return decision;
  },

  elementInitializer() {
    if(this.hasAttribute("initial_location")) {
      this.move(this.getAttributeValue("initial_location"));
    }
  },

  move(to_location_id) {
    console.log("Moving |"+this.id+"| to |"+to_location_id+"|");

    if(this.hasAttribute("location")) {
      const from_location_id = this.getAttributeValue("location");
      this.runEvent("leave", {location_id: from_location_id});
      const from_location = $(from_location_id);
      from_location.runEvent("actor_leaves", {actor_id: this.id});
    }

    this.setAttribute("location", to_location_id);
    this.runEvent("enter", {location_id: to_location_id});
    const to_location = $(to_location_id);
    to_location.runEvent("actor_enters", {actor_id: this.id});
  }
};

function RezActor(id, attributes) {
  this.id = id;
  this.auto_id_idx = 0;
  this.game_object_type = "actor";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
};

RezActor.prototype = actor_proto;
RezActor.prototype.constructor = RezActor;
window.Rez.Actor = RezActor;

//-----------------------------------------------------------------------------
// Asset
//-----------------------------------------------------------------------------

let asset_proto = {
  __proto__: basic_object,

  elementInitializer() {
    this.type = this.assetType();
  },

  tag() {
    if(this.isImage()) {
      return this.imageTag();
    } else if(this.isAudio()) {
      return this.audioTag();
    } else if(this.isVideo()) {
      return this.videoTag();
    } else {
      throw "No tag implementation for MIME type: " + this.type + "!";
    }
  },

  assetType() {
    const mime_type = this.getAttributeValue("detected_mime_type");
    if(typeof(mime_type) == "undefined") {
      throw "No MIME information available for asset: " + this.id;
    }
    return mime_type.split("/")[0];
  },

  isImage() {
    return this.type == "image";
  },

  isAudio() {
    return this.type == "audio";
  },

  isVideo() {
    return this.type == "video";
  },

  isText() {
    return this.type == "text";
  },

  getDimensions() {
    const w = this.getAttribute("width");
    const h = this.getAttribute("height");

    if(w && h) {
      return "width: " + w + "; height: " + h;
    } else if(w) {
      return "width: " + w;
    } else if(h) {
      return "height: " + h;
    } else {
      return "";
    }
  },

  audioTag() {
    console.log("Audio tags not implemented");
    return "";
  },

  imageTag() {
    const style = this.getDimensions();
    return new Handlebars.SafeString("<img src='" + this.path + "' style='" + style + "' />");
  },

  videoTag() {
    console.log("Video tags not implemented");
    return "";
  }
};

function RezAsset(id, path, attributes) {
  this.id = id;
  this.game_object_type = "asset";
  this.path = path;
  this.attributes = attributes;
  this.type = this.assetType();
  this.properties_to_archive = ["type"];
  this.changed_attributes = [];
}

RezAsset.prototype = asset_proto;
RezAsset.prototype.constructor = RezAsset;
window.Rez.Asset = RezAsset;

//-----------------------------------------------------------------------------
// Card
//-----------------------------------------------------------------------------

let card_proto = {
  __proto__: basic_object,
  targetType: "card"
};

function RezCard(id, template, attributes) {
  this.id = id;
  this.game_object_type = "card";
  this.template = template;
  this.attributes = attributes;
  this.render_id = 0;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezCard.prototype = card_proto;
RezCard.prototype.constructor = RezCard;
window.Rez.Card = RezCard;

//-----------------------------------------------------------------------------
// Decision
//-----------------------------------------------------------------------------

/*
 * RezDecision is an object type that can be passed to user-written filters.
 * Conceptually it's a simplified abstraction of the RezDynamicLink.
 *
 * When given a decision the caller should call either of `yes()` or
 * `no(reason)` to instruct the calling code about what to do.
 */

let decision_proto = {
  yes() {
    this.made = true;
    this.result = true;
    this.default = false;
    return this;
  },

  default_yes() {
    this.made = true;
    this.result = true;
    this.default = true;
  },

  no(reason = "none given") {
    this.made = true;
    this.result = false;
    this.reason = reason;
    this.default = false;
    return this;
  },

  default_no() {
    this.made = true;
    this.result = false;
    this.default = true;
  },

  wasMade() {
    return this.made;
  },

  usedDefault() {
    return this.default;
  },

  data() {
    return this.data;
  },

  setData(key, value) {
    this.data[key] = value;
    return this;
  },

  result() {
    return this.result;
  },

  purpose() {
    return this.purpose;
  },

  reason() {
    return this.reason;
  },
};

function RezDecision(purpose, data = {}) {
  this.purpose = purpose;
  this.made = false;
  this.decision = false;
  this.reason = "";
  this.data = data;
  this.default = false;
}

RezDecision.prototype = decision_proto;
RezDecision.prototype.constructor = RezDecision;
window.Rez.Decision = RezDecision;

//-----------------------------------------------------------------------------
// Die
//-----------------------------------------------------------------------------

let die_proto = {
  between: function(min, max) {
    return Math.floor(min + Math.random() * (max - min + 1));
  },

  die() {
    return this.between(1, this.sides);
  },

  rollOnce() {
    let sum = this.modifier;
    for(let i = 0; i<this.count; i++) {
      sum += this.die();
    }
    return sum;
  },

  cl_avg(sum) {
    const f = Math.random() < 0.5 ? Math.ceil : Math.floor;
    return f(sum/this.rounds);
  },

  roll() {
    let sum = 0;
    for(let i = 0; i<this.rounds; i++) {
      sum += this.rollOnce();
    }
    return this.cl_avg(sum);
  }
};

function RezDie(count = 1, sides = 6, modifier = 0, rounds = 1) {
  this.count = count;
  this.sides = sides;
  this.modifier = modifier;
  this.rounds = rounds;
}

RezDie.prototype = die_proto;
RezDie.prototype.constructor = RezDie;
window.Rez.Die = RezDie;

//-----------------------------------------------------------------------------
// DynamicLink
//-----------------------------------------------------------------------------

let dynamic_link_proto = {
  inactive_class: "inactive",
  choosen: false,
  display: true,
  markup: "<strong>No text for dynamic link</strong>",
  card: null,

  game() {
    return this.card.game;
  },

  allow(response, target_id) {
    if(typeof(response) != "function" && target_id == null ) {
      throw new Error("Unable to build dynamic link, no target specified.");
    } else if(this.game().getTarget(target_id) == null) {
      throw new Error("Unable to build dynamic link, no card or scene '" + target_id + "' exists in the game.");
    }

    this.choosen = true;

    if(typeof(response) == "function") {
      this.markup = response();
    } else {
      this.markup = "<a href=\"javascript:void(0)\" data-target=\"" + target_id + "\">" + response + "</a>";
    }
  },

  deny(text, as_link) {
    this.choosen = true;

    if(as_link == null || as_link) {
      this.markup = "<a href=\"javascript:void(0)\" class=\""+this.inactive_class+"\">" + text + "</a>";
    } else {
      this.markup = "<span class=\"" + this.inactive_class + "\">" + text + "</span>";
    }
  },

  hide() {
    this.choosen = true;
    this.display = false;
  },

};

function RezDynamicLink(card) {
  this.card = card;
  this.game_object_type = "dynamic_link";
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezDynamicLink.prototype = dynamic_link_proto;
RezDynamicLink.prototype.constructor = RezDynamicLink;
window.Rez.DynamicLink = RezDynamicLink;

//-----------------------------------------------------------------------------
// Effect
//-----------------------------------------------------------------------------

let effect_proto = {
  __proto__: basic_object
};

function RezEffect(id, attributes) {
  this.id = id;
  this.game_object_type = "effect";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezEffect.prototype = effect_proto;
RezEffect.prototype.constructor = RezEffect;
window.Rez.Effect = RezEffect;

//-----------------------------------------------------------------------------
// Faction
//-----------------------------------------------------------------------------

let faction_proto = {
  __proto__: basic_object
};

function RezFaction(id, attributes) {
  this.id = id;
  this.game_object_type = "faction";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezFaction.prototype = faction_proto;
RezFaction.prototype.constructor = RezFaction;
window.Rez.Faction = RezFaction;

//-----------------------------------------------------------------------------
// Game
//-----------------------------------------------------------------------------

let game_proto = {
  __proto__: basic_object,
  targetType: "game",

  $(id) {
    return this.getGameObject(id);
  },

  saveFileName(prefix) {
    const now = new Date();
    const formatter = (num) => {return String(num).padStart(2, "0");}
    const date_parts = [now.getFullYear()-2000, now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()];
    const date_mapped = date_parts.map(formatter);
    const date_joined = date_mapped.join("");
    return prefix.toSnakeCase() + "_" + date_joined + ".json";
  },

  dataWithArchivedObjects(data) {
    console.dir(this);
    console.log("Checking " + this.game_objects.size + " objects.");
    this.game_objects.forEach(function(obj, id) {
      console.log(id + " -> " + obj.needsArchiving());
      if(obj.needsArchiving()) {
        data["objs"] = data["objs"] || {};
        data["objs"][obj.id] = obj;
      }
    });
    console.log("Done");
    return data;
  },

  toJSON() {
    let data = this.archiveDataContainer();
    data = this.dataWithArchivedAttributes(data);
    data = this.dataWithArchivedProperties(data);
    data = this.dataWithArchivedObjects(data);

    return {
      "rez_archive": this.getAttribute("archive_format"),
      "data": data
    };
  },

  archive() {
    const archived = {};

    return JSON.stringify(this, function (key, value) {
      console.log("archive: ["+key+"]");

      if(key == "" || value == null) { // This is the game itself
        archived["game"] = true;
        return value;
      } else if(value.isGameObject()) { // This is a game object
        const goid = value.id; // GameObjectID
        console.log("<- is a game object: " + goid);
        if(archived[goid]) {
          console.log("<- is already archived");
          return {
            json$safe: true,
            type: "ref",
            game_object_type: value.game_object_type,
            game_object_id: value.id
          }
        } else {
          console.log("<- archived");
          archived[goid] = true;
          return value;
        }
      } else if(typeof(value) == "function") {
        return {
          json$safe: true,
          type: "function",
          value: value.toString()
        }
      } else {
        console.log("<- value:" + value);
        return value;
      }
      return value;
    });
  },

  save() {
    this.runEvent("save", {});

    const file = new File([this.archive()], this.saveFileName(this.getAttribute("name")), {type: "application/json"});
    const link = document.createElement("a");
    link.style.display = "none";
    link.href = URL.createObjectURL(file);
    link.download = file.name;
    document.body.appendChild(link);
    link.click();
    setTimeout(() => {URL.revokeObjectURL(link.href);
                      link.parentNode.removeChild(link);
                     }, 0);
  },

  load(json) {
    const wrapper = JSON.parse(json);

    const archive_version = wrapper["rez_archive"];
    if(typeof(archive_version) == "undefined") {
      throw "JSON does not represent a Rez game archive!"
    } else if(archive_version != this.getAttribute("archive_format")) {
      throw "JSON is v" + archive_version + " which is not supported (v" + this.getAttribute("archive_format") + ")!";
    }

    const data = wrapper["data"];
    if(typeof(data) == "undefined") {
      throw "JSON does not contain data archive!";
    }

    // Load the game's attributes and properties
    this.loadData(data);

    const objs = data["objs"];
    if(typeof(objs) == "object") {
      for(const [id, obj_data] of Object.entries(objs)) {
        const obj = this.getGameObject(id);
        obj.loadData(obj_data);
      }
    }

    this.runEvent("load", {});
  },

  indexObjectForTag(obj, tag) {
    let objects = this.tag_index[tag];
    if(!objects) {
      objects = new Set([obj.id]);
      this.tag_index[tag] = objects;
    } else {
      objects.add(obj.id);
    }
  },

  unindexObjectForTag(obj, tag) {
    let objects = this.tag_index[tag];
    if(objects) {
      objects.delete(obj.id);
    }
  },

  addToTagIndex(obj) {
    const tags = obj.getAttributeValue("tags", new Set());
    tags.forEach((tag) => this.indexObjectForTag(obj, tag));
  },

  removeFromTagIndex(obj) {
    const tags = obj.getAttributeValue("tags", new Set());
    tags.forEach((tag) => this.unindexObjectForTag(obj, tag));
  },

  addGameObject(obj) {
    if(!obj.isGameObject()) {
      console.dir(obj);
      throw "Attempt to register non-game object!";
    }

    obj.game = this;
    this.game_objects.set(obj.id, obj);
    this.addToTagIndex(obj);

    // If we are in the pre-init we collect objects to be inited once game
    // setup is complete. We expect cloned objects to already have been
    // init'd before they get added.
    if(this.init_objects) {
      this.init_objects.push(obj);
    }
  },

  getGameObject(id, should_throw = true) {
    if(!this.game_objects.has(id)) {
      if(should_throw) {
        throw "No such ID |"+id+"| found!";
      } else {
        return null;
      }
    }
    return this.game_objects.get(id);
  },

  /*
   * We can cheat looking up a relationship because we know how their IDs
   * are constructed.
   */
  getRelationship(source_id, target_id) {
    const rel_id = "rel_" + source_id + "_" + target_id;
    return this.getGameObject(rel_id, false);
  },

  <%# getByProto(proto) {
    return Array.from(this.game_objects.values).filter((obj) => obj.constructor.prototype == proto);
  }, %>

  getTaggedWith(tag) {
    const objects = this.tag_index[tag];
    if(objects) {
      return Array.from(objects);
    } else {
      return [];
    }
  },

  getAll(target_type) {
    return Array.from(this.game_objects.values()).filter((obj) => obj.game_object_type == target_type);
  },

  getCurrentScene() {
    return this.getGameObject(this.current_scene_id);
  },

  setCurrentScene(new_scene_id) {
    if(new_scene_id == null) {
      throw "new_scene_id cannot be null!";
    }

    this.current_scene_id = new_scene_id;
    const scene = this.getCurrentScene();
    this.setViewContent(scene.getLayout());
    this.getCurrentScene().start();
  },

  setViewContent(content) {
    this.view.getLayout().addContent(content);
  },

  getTarget(target_id) {
    if(target_id == this.id) {
      return this;
    } else {
      return this.getGameObject(target_id);
    }
  },

  updateView() {
    console.log("Updating the view");
    this.view.update();
  },

  interludeWithScene(interlude_scene_id) {
    if(interlude_scene_id == null) {
      throw "interlude_scene_id cannot be null!";
    } else if(this.getCurrentScene() == null) {
      throw "cannot interlude without a current scene!";
    }

    console.log("Interlude from " + this.current_scene_id + " to " + interlude_scene_id);

    // Save the state of the current scene
    this.pushScene();

    this.setCurrentScene(interlude_scene_id);
    this.updateView();
  },

  resumePrevScene() {
    console.log("Resume from " + this.current_scene_id);
    if(this.scene_stack.length < 1) {
      throw "Cannot resume without a scene on the stack!";
    } else {
      // Let the interlude know we're done
      this.getCurrentScene().finish();

      this.popScene();
      this.updateView();
    }
  },

  pushScene() {
    this.getCurrentScene().interrupt();
    this.scene_stack.push(this.current_scene_id);
    this.view.pushLayout(new RezSingleLayout(this));
  },

  popScene() {
    this.view.popLayout();
    this.current_scene_id = this.scene_stack.pop();
    this.getCurrentScene().resume();
  },

  setViewLayout(layout) {
    this.view.setLayout(layout);
  },

  start(container_id) {
    console.log("> Game.start");
    this.view = new RezView(container_id, this, new RezSingleLayout(this));

    // Init every object, will also trigger on_init for any object that defines it
    this.init_objects.forEach((obj) => {obj.init()});
    this.init_objects = null;

    // this.container_id = container_id;
    this.runEvent("start", {});

    const initial_scene_id = this.getAttributeValue("initial_scene");
    this.setCurrentScene(initial_scene_id);
  },

  getEnabledSystems() {
    return this.
      getAll("system").
        filter((system) => system.getAttribute("enabled") == true).
        sort((sys1, sys2) => sys1.getAttributeValue("priority") > sys2.getAttributeValue("priority"));
  },

  // Handle events coming from the browser

  handleBrowserEvent(evt) {
    if(evt.type == "click") {
      return this.handleBrowserClickEvent(evt);
    } else if(evt.type == "input") {
      return this.handleBrowserInputEvent(evt);
    } else if(evt.type == "submit") {
      return this.handleBrowserSubmitEvent(evt);
    } else {
      return false;
    }
  },

  handleBrowserClickEvent(evt) {
    if(!evt.target.dataset.event) {
      return false;
    }

    const event = evt.target.dataset.event;
    if(event == 'card') {
      return this.handleCardEvent(evt);
    } else if(event == 'shift') {
      return this.handleShiftEvent(evt);
    } else if(event == 'interlude') {
      return this.handleInterludeEvent(evt);
    } else if(event == 'resume') {
      return this.handleResumeEvent(evt);
    } else if(event == 'event') {
      return this.handleCustomEvent(evt);
    } else {
      throw "Unexpected event type: " + event + "!";
    }
  },

  handleCardEvent(evt) {
    console.log("Handle card event");
    const card_id = evt.target.dataset.target;
    this.getCurrentScene().playCardWithId(card_id);
    return true;
  },

  handleShiftEvent(evt) {
    console.log("Handle shift event");
    const scene_id = evt.target.dataset.target;
    this.setCurrentScene(scene_id);
    return true;
  },

  handleInterludeEvent(evt) {
    console.log("Handle interlude event");
    const scene_id = evt.target.dataset.target;
    this.interludeWithScene(scene_id);
    return true;
  },

  handleResumeEvent(evt) {
    console.log("Handle resume event");
    this.resumePrevScene();
    return true;
  },

  handleBrowserInputEvent(evt) {
    console.log("Handle input event");
    const card_div = evt.target.closest(".active_card > div.card, .active_block > div.card");
    if(!card_div) {
      throw "Cannot find div for input " + evt.target.id + "!";
    }

    const card_id = card_div.dataset.card;
    if(!card_id) {
      throw "Cannot get card id for input" + evt.target.id + "!";
    }

    const card = $(card_id);
    return card.runEvent("input", {evt: evt});
  },

  handleBrowserSubmitEvent(evt) {
    console.log("Handle submit event");

    const form_name = evt.target.getAttribute("name");
    if(!form_name) {
      throw "Cannot get form name!";
    }

    const card_div = evt.target.closest(".active_card > div.card, .active_block > div.card");
    if(!card_div) {
      throw "Cannot find div for form: " + form_name + "!";
    }

    const card_id = card_div.dataset.card;
    const card = $(card_id);

    return card.runEvent(form_name, {form: evt.target});
  },

  runTick() {
    this.getEnabledSystems().forEach(function(system) {
      system.runEvent("tick", this.wmem);
    });
  }
};

function RezGame(template, attributes) {
  this.id = "game";
  this.game_object_type = "game";
  this.attributes = attributes;
  this.tag_index = {};
  this.scene_stack = [];
  this.current_scene_id = null;
  this.template = template;
  this.wmem = {game: this};
  this.game_objects = new Map();
  this.init_objects = [this];
  this.properties_to_archive = ["scene_stack", "current_scene_id", "wmem", "tag_index", "renderer"];
  this.changed_attributes = [];
  this.$ = this.getGameObject;
}

RezGame.prototype = game_proto;
RezGame.prototype.constructor = RezGame;
window.Rez.Game = RezGame;

//-----------------------------------------------------------------------------
// Group
//
// Group represents a group of assets that is dynamically generated by the
// include_tag and exclude_tag attributes.
//-----------------------------------------------------------------------------

let group_proto = {
  __proto__: basic_object,

  elementInitializer() {
    this.filterAssets();
  },

  filterAssets() {
    // Start with all assets
    let assets = this.game.getAll("asset");

    // Does the asset have the right type
    const selected_type = this.getAttributeValue("type");
    assets = assets.filter((asset) => {return asset.type == selected_type});

    // Assets without tags can't be in a group
    assets = assets.filter((asset) => {return asset.hasAttribute("tags") && asset.getAttributeValue("tags").size > 0});

    // If there is an include filter, filter those without the relevant tags
    const include_tags = this.getAttributeValue("include_tags", new Set());
    if(include_tags.size > 0) {
      assets = assets.filter((asset) => {
        const tags = asset.getAttributeValue("tags");
        return tags.hasSubset(include_tags);
      });
    }

    // If there is an exclude filter, filter those with the relevant tags
    const exclude_tags = this.getAttributeValue("exclude_tags", new Set());
    if(exclude_tags.size > 0) {
      assets = assets.filter((asset) => {
        const tags = asset.getAttributeValue("tags");
        return tags.intersection(exclude_tags).size == 0;
      });
    }

    if(assets.size == 0) {
      console.log("Attempt to create group that matches 0 assets!");
    }

    this.assets = assets.map((asset) => {return asset.id}).fy_shuffle();
  },

  randomAssetId() {
    if(this.assets.size == 0) {
      this.filterAssets();
    }

    const asset_id = this.assets.shift();
    if(typeof(asset_id) == "undefined") {
      throw "Attempt to get random asset from Group " + this.id + " with no matching assets!";
    }

    return asset_id;
  }
};

function RezGroup(id, attributes) {
  this.id = id;
  this.game_object_type = "group";
  this.attributes = attributes;
  this.assets = [];
  this.properties_to_archive = ["assets"];
  this.changed_attributes = [];
}

RezGroup.prototype = group_proto;
RezGroup.prototype.constructor = RezGroup;
window.Rez.Group = RezGroup;

//-----------------------------------------------------------------------------
// Inventory
//-----------------------------------------------------------------------------

/*
 * A RezInventory is an object that holds RezItems in separate containers
 * designated by RezSlots.
 */

let inventory_proto = {
  __proto__: basic_object,

  slots() {
    return this.getAttributeValue("slots");
  },

  addContentHolderForSlot(slot_id) {
    this.contents[slot_id] = [];
  },

  elementInitializer() {
    for(const slot_id of this.slots()) {
      this.addContentHolderForSlot(slot_id);
    }
  },

  slotIsOccupied(slot_id) {
    return this.getContentsForSlot(slot_id).length == 0;
  },

  getContentsForSlot(slot_id) {
    return this.contents[slot_id];
  },

  appendContentToSlot(slot_id, item_id) {
    this.contents[slot_id].push(item_id);
  },

  setContentsForSlot(slot_id, contents) {
    this.contents[slot_id] = contents;
  },

  countItemsInSlot(slot_id) {
    return this.getContentsForSlot(slot_id).length;
  },

  /*
   * Determines whether the specified item is contained in any slot in this inventory.
   *
   * Either returns the slot_id that contains the item, or null.
   */
  containsItem(item_id) {
    for(const slot_id in this.contents) {
      const contents = this.getContentsForSlot(slot_id);
      if(contents.some((contained_item_id) => {
        return contained_item_id == item_id;
      })) {
        return slot_id;
      }
    }
    return null;
  },

  isOwned() {
    return this.hasAttribute("owner");
  },

  ownerId() {
    return this.getAttributeValue("owner");
  },

  owner() {
    return this.game.$(this.ownerId());
  },

  itemFitsInSlot(slot_id, item_id) {
    const capacity = this.game.$(slot_id).capacity();
    const size = this.game.$(item_id).size();
    const current_size = this.countItemsInSlot(slot_id);

    return (current_size + size) <= capacity;
  },

  slotAcceptsItem(slot_id, item_id) {
    const accepts = this.game.$(slot_id).getAttributeValue("accepts");
    const type = this.game.$(item_id).getAttributeValue("type");

    return type == accepts;
  },

  canAddItemForSlot(slot_id, item_id) {
    const decision = new RezDecision("canItemForSlot");

    if(!this.slotAcceptsItem(slot_id, item_id)) {
      decision.no("slot doesn't take this kind of item").setData("failed_on", "accepts");
    } else if(!this.itemFitsInSlot(slot_id, item_id)) {
      decision.no("does not fit").setData("failed_on", "fits");
    } else if(this.isOwned()) {
      const actor_decision = this.owner().checkItem(this.id, slot_id, item_id);
      if(actor_decision.result()) {
        decision.yes();
      } else {
        decision.no(actor_decision.reason()).setData("failed_on", "actor");
      }
    } else {
      decision.yes();
    }

    return decision;
  },

  addItemToSlot(slot_id, item_id) {
    this.appendContentToSlot(slot_id, item_id);

    this.runEvent("insert", {slot_id: slot_id, item_id: item_id});

    const slot = this.game.$(slot_id);
    slot.runEvent("insert", {inventory_id: this.id, item_id: item_id});

    this.applyEffects(item_id);
  },

  applyEffects(item_id) {
    if(!this.getAttributeValue("apply_effects", false)) {
      return;
    }

    const item = this.game.$(item_id);
    if(!item.hasAttribute("effects")) {
      return;
    }

    if(!this.hasAttribute("owner")) {
      return;
    }

    const effects = item.getAttributeValue("effects");
    const owner = this.getAttributeValue("owner");

    for(const effect_id of effects) {
      owner.applyEffect(effect_id, item_id);
    }
  },

  removeItemFromSlot(slot_id, item_id) {
    const contents = this.getContentsForSlot(slot_id);
    if(!contents.includes(item_id)) {
      throw "Attempt to remove item |"+item_id+"| from slot |"+slot_id+"| on inventory |"+this.id+"|. No such item found!";
    }

    const remaining_contents = contents.filter((id) => {return id != item_id;})
    this.setContentsForSlot(slot_id, new_contents);

    const slot = this.game.$(slot_id);
    slot.runEvent("remove", {inventory: this.id, item: item_id});
    this.runEvent("remove", {slot: slot_id, item: item_id});

    this.removeEffects(item_id);
  },

  removeEffects(item_id) {
    if(!this.getAttributeValue("apply_effects", false)) {
      return;
    }

    const item = this.game.$(item_id);
    if(!item.hasAttribute("effects")) {
      return;
    }

    if(!this.hasAttribute("owner")) {
      return;
    }

    const effects = item.getAttributeValue("effects");
    const owner = this.getAttributeValue("owner");

    for(const effect_id of effects) {
      owner.removeEffect(effect_id, item_id);
    }
  }
};

function RezInventory(id, attributes) {
  this.id = id;
  this.game_object_type = "inventory";
  this.contents = {};
  this.attributes = attributes;
  this.properties_to_archive = ["contents"];
  this.changed_attributes = [];
}

RezInventory.prototype = inventory_proto;
RezInventory.prototype.constructor = RezInventory;
window.Rez.Inventory = RezInventory;

//-----------------------------------------------------------------------------
// Item
//-----------------------------------------------------------------------------

let item_proto = {
  __proto__: basic_object,

  size() {
    return this.getAttributeValue("size");
  }
};

function RezItem(id, template, attributes) {
  this.id = id;
  this.template = template;
  this.auto_id_idx = 0;
  this.game_object_type = "item";
  this.attributes = attributes;
  this.properties_to_archive = ["auto_id_idx"];
  this.changed_attributes = [];
}

RezItem.prototype = item_proto;
RezItem.prototype.constructor = RezItem;
window.Rez.Item = RezItem;

//-----------------------------------------------------------------------------
// Location
//-----------------------------------------------------------------------------

let location_proto = {
  __proto__: basic_object
};

function RezLocation(id, template, attributes) {
  this.id = id;
  this.game_object_type = "location";
  this.attributes = attributes;
  this.template = template;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezLocation.prototype = location_proto;
RezLocation.prototype.constructor = RezLocation;
window.Rez.Location = RezLocation;

//-----------------------------------------------------------------------------
// List
//-----------------------------------------------------------------------------

let list_proto = {
  __proto__: basic_object,

  //---------------------------------------------------------------------------
  // List
  //---------------------------------------------------------------------------

  /*
   *  Returns a random element of the list with replacement.
  */
  randomElement() {
    return this.values().randomElement();
  },

  //---------------------------------------------------------------------------
  // Cycle
  //---------------------------------------------------------------------------

  /*
   * Treat the list as a repeating cycle. Each cycle identified by an id
   * is separate.
  */
  nextForCycle(cycle_id) {
    let cycle = this.cycles[cycle_id];
    if(typeof(cycle) == "undefined") {
      cycle = 0;
    }

    const value = this.values().at(cycle);

    cycle += 1;
    this.cycles[cycle_id] = cycle;

    return value;
  },

  //---------------------------------------------------------------------------
  // Bag
  //---------------------------------------------------------------------------

  /*
   * Returns a random element from among those left in the bag. If the bag
   * is empty, returns nil.
  */
  randomRemaining(bag_id) {
    let bag = this.getBag(bag_id);
    if(bag.length == 0) {
      return null;
    } else {
      return bag.randomElement();
    }
  },

  /*
   * Removes the specified value from those in the bag
  */
  take_from(bag_id, value) {
    let bag = this.getBag(bag_id);
    bag = bag.filter((elem) => elem != value);
    this.setBag(bag_id, bag);
  },

  getBag(bag_id) {
    return this.bags[bag_id] ?? this.create_bag(bag_id);
  },

  setBag(bag_id, bag) {
    this.bags[bag_id] = bag;
  },

  create_bag(bag_id) {
    const bag = Array.from(this.values());
    this.bags[bag_id] = bag;
    return bag;
  },

  //---------------------------------------------------------------------------
  // Walk
  //---------------------------------------------------------------------------

  /*
   * Returns a random element of the list without replacement, i.e. no item
   * will be returned twice in any given walk. At the end of a walk (i.e. all items
   * have been returned), a new walk is automatically begun.
  */
  randomWalk(walk_id) {
    let walk = this.getWalk(walk_id);
    if(walk.length == 0) {
      walk = this.resetWalk(walk_id);
    } else {
      const idx = walk.shift();
      return this.values().at(idx);
    }
  },

  getWalk(walk_id) {
    let walk = this.walks[walk_id];
    if(typeof(walk) == "undefined") {
      walk = this.resetWalk(walk_id);
    }
    return walk;
  },

  resetWalk(walk_id) {
    const walk = Array.from(this.values().keys()).fy_shuffle();
    this.walks[walk_id] = walk;
    return walk;
  },

  values() {
    return this.attributes["values"];
  }
};

function RezList(id, attributes) {
  this.id = id;
  this.game_object_type = "list";
  this.attributes = attributes;
  this.cycles = {};
  this.walks = {};
  this.bags = {};
  this.properties_to_archive = ["cycles", "walks"];
  this.changed_attributes = [];
}

RezList.prototype = list_proto;
RezList.prototype.constructor = RezList;
window.Rez.List = RezList;

//-----------------------------------------------------------------------------
// Object
//
// The RezObject is a way for authors to define their own types of object
// that don't belong to one of the provided functionalities (e.g. actors,
// items, and the like). An author can define a RezObject and put whatever
// data they like into it and make use of it from their own scripted functions
// or behaviour tasks.
//-----------------------------------------------------------------------------

let object_proto = {
  __proto__: basic_object
};

function RezObject(id, attributes) {
  this.id = id;
  this.game_object_type = "object";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezObject.prototype = object_proto;
RezObject.prototype.constructor = RezObject;
window.Rez.Object = RezObject;

//-----------------------------------------------------------------------------
// Plot
//-----------------------------------------------------------------------------

let plot_proto = {
  __proto__: basic_object,

  isActive() {
    return this.getAttribute("tick") > 0;
  },

  isComplete() {
    return this.getAttribute("tick") == this.getAttribute("ticks");
  },

  tick() {
    let curr_tick = this.getAttribute("tick");
    const max_ticks = this.getAttribute("ticks");
    if(curr_tick < max_ticks) {
      curr_tick += 1;
      this.setAttribute("tick", curr_tick);
      this.runEvent("tick", {});
    }
  }
};

function RezPlot(id, attributes) {
  this.id = id;
  this.game_object_type = "plot";
  this.status = 0;
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezPlot.prototype = plot_proto;
RezPlot.prototype.constructor = RezPlot;
window.Rez.Plot = RezPlot;

//-----------------------------------------------------------------------------
// Relationship
//-----------------------------------------------------------------------------

let relationship_proto = {
  __proto__: basic_object,

  getAffinity() {
    return this.getAttributeValue("affinity");
  },

  checkInRange(affinity) {
    if(typeof(affinity) != "number") {
      throw "Cannot set affinity to a non-numeric value!";
    } else if(affinity < -5.0) {
      throw "-5.0 is the lowest affinity value";
    } else if(affinity > 5.0) {
      throw "5.0 is the greatest affinity value";
    }
  },

  setAffinity(affinity) {
    const prior_affinity = this.getAffinity();
    this.checkInRange(affinity);
    this.setAttribute("affinity", affinity);
    this.runEvent("change_affinity", {prior: cur_affinity, current: affinity});
  },

  alterAffinity(change) {
    if(typeof(change) != "number") {
      throw "Affinity values are numbers!";
    }
    const cur_affinity = this.getAffinity();
    const new_affinity = cur_affinity + change;
    this.checkInRange(new_affinity);
    this.setAttribute("affinity", new_affinity);
    this.runEvent("change_affinity", {prior: cur_affinity, current: new_affinity});
  },

  getSource() {
    return this.getAttributeValue("source");
  },

  getTarget() {
    return this.getAttributeValue("target");
  }
}

function RezRelationship(id, attributes) {
  this.id = id;
  this.game_object_type = "relationship";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezRelationship.prototype = relationship_proto;
RezRelationship.prototype.constructor = RezRelationship;
window.Rez.Relationship = RezRelationship;

//-----------------------------------------------------------------------------
// Scene
//-----------------------------------------------------------------------------

let scene_proto = {
  __proto__: basic_object,
  targetType: "scene",

  getCurrentCard() {
    return this.game.$(this.current_card_id);
  },

  getInitialCard() {
    return this.game.$(this.getAttributeValue("initial_card"));
  },

  finish() {
    this.runEvent("finish", {});
  },

  finishCurrentCard() {
    if(this.current_card_id != null) {
      const card = this.getCurrentCard();
      if(card) {
        card.runEvent("finish", {scene: this.id});
        this.runEvent("finish_card", {card: card.id});
      }
    }
  },

  startNewCard() {
    const card = this.getCurrentCard();
    if(card) {
      this.runEvent("start_card", {card: card.id});
      card.runEvent("start", {scene: this.id});

      const block = new RezBlock(card);
      this.getLayout().addContent(block);
    }
  },

  playCardWithId(new_card_id) {
    console.log("Playing card: " + new_card_id);

    // Obviously if you try to set no card we should blow up
    if(new_card_id == null) {
      throw "Cannot specify null card_id!";
    }

    this.finishCurrentCard();

    this.current_card_id = new_card_id;
    this.startNewCard();

    this.game.updateView();
    this.getCurrentCard().runEvent("ready", {});
  },

  getCard(card_id) {
    const card = this.$(card_id);
    if(card.game_object_type != "card") {
      throw "Attempt to get id which does not correspond to a card";
    }
    return card;
  },

  createLayout() {
    const layout_mode = this.getAttributeValue("layout_mode");
    if(layout_mode == "continuous") {
      return new RezMultiLayout(this);
    } else {
      return new RezSingleLayout(this);
    }
  },

  getLayout() {
    this.layout = this.layout ?? this.createLayout();
    return this.layout;
  },

  reset() {
    this.cards_played = [];
    this.current_card_id = null;
    this.current_render = null;
  },

  interrupt() {
    console.log("Interrupting " + this.id);
    this.runEvent("interrupt", {});
  },

  resume() {
    console.log("Resuming " + this.id);
    this.runEvent("resume", {});
  },

  start() {
    this.reset();
    this.init();
    this.runEvent("start", {});
    this.playCardWithId(this.getAttribute("initial_card"));
  }
};

function RezScene(id, template, attributes) {
  this.id = id;
  this.game_object_type = "scene";
  this.template = template;
  this.attributes = attributes;
  this.properties_to_archive = ["current_card_id", "current_render", "cards_played"];
  this.changed_attributes = [];
  this.reset();
}

RezScene.prototype = scene_proto;
RezScene.prototype.constructor = RezScene;
window.Rez.Scene = RezScene;

//-----------------------------------------------------------------------------
// Slot
//-----------------------------------------------------------------------------

let slot_proto = {
  __proto__: basic_object,

  capacity() {
    return this.getAttributeValue("capacity");
  },
};

function RezSlot(id, attributes) {
  this.id = id;
  this.game_object_type = "slot";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezSlot.prototype = slot_proto;
RezSlot.prototype.constructor = RezSlot;
window.Rez.Slot = RezSlot;

//-----------------------------------------------------------------------------
// System
//-----------------------------------------------------------------------------

let system_proto = {
  __proto__: basic_object
};

function RezSystem(id, attributes) {
  this.id = id;
  this.game_object_type = "system";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezSystem.prototype = system_proto;
RezSystem.prototype.constructor = RezSystem;
window.Rez.System = RezSystem;

//-----------------------------------------------------------------------------
// Task
//-----------------------------------------------------------------------------

let task_proto = {
  __proto__: basic_object,

  option(name) {
    return this.options[name];
  },

  firstChild() {
      return this.children[0];
  },

  secondChild() {
    return this.children[1];
  },

  getChild(idx) {
    return this.children[idx];
  },

  children() {
    return this.children;
  },

  childCount() {
    return this.children.length;
  },

  execute(wmem) {
    // By definition this is a function of two attributes
    // (task, wmem)
    const handler = this.attributes["execute"];
    return handler(this, wmem);
  },

  instantiate(options, children = []) {
    const task = this.copyWithAutoId();
    task.options = options;
    task.children = children;
    return task;
  }
};

function RezTask(id, attributes) {
  this.id = id;
  this.game_object_type = "task";
  this.auto_id_idx = 0;
  this.options = {};
  this.children = [];
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezTask.prototype = task_proto;
RezTask.prototype.constructor = RezTask;
window.Rez.Task = RezTask;

//-----------------------------------------------------------------------------
// Zone
//-----------------------------------------------------------------------------

let zone_proto = {
  __proto__: basic_object,

  addLocation(location) {
    location.zone = this;
    this.locations[location.id] = location;
  },

  getLocation(location_id) {
    return this.locations[location_id];
  }
};

function RezZone(id, attributes) {
  this.id = id;
  this.game_object_type = "zone";
  this.locations = {};
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezZone.prototype = zone_proto;
RezZone.prototype.constructor = RezZone;
window.Rez.Zone = RezZone;

//-----------------------------------------------------------------------------
// Initialize Game Objects
//-----------------------------------------------------------------------------

const game = new RezGame(
  Handlebars.template(<%= @game.template %>),
  <%= encode_attributes(@game.attributes) %>
);

basic_object.game = game;

/* Encode tasks that will be referred to in behaviours attributes */
<%= for {id, task} <- @game.tasks do %>
game.addGameObject(
  new RezTask(
    "<%= id %>",
    <%= encode_attributes(task.attributes) %>
  )
);
<% end %>

/* Encode game objects */
<%= for {id, actor} <- @game.actors do %>
game.addGameObject(
  new RezActor(
    "<%= id %>",
    <%= encode_attributes(actor.attributes) %>
  )
);
<% end %>

<%= for {id, asset} <- @game.assets do %>
game.addGameObject(
  new RezAsset(
    "<%= id %>",
    "<%= Asset.asset_path(asset) %>",
    <%= encode_attributes(asset.attributes) %>
  )
);
<% end %>

<%= for {id, card} <- @game.cards do %>
game.addGameObject(
  new RezCard(
    "<%= id %>",
    Handlebars.template(<%= card.template %>),
    <%= encode_attributes(card.attributes) %>
  )
);
<% end %>

<%= for {id, effect} <- @game.effects do %>
game.addGameObject(
  new RezEffect(
    "<%= id %>",
    <%= encode_attributes(effect.attributes) %>
  )
);
<% end %>

<%= for {id, faction} <- @game.factions do %>
game.addGameObject(
  new RezFaction(
    "<%= id %>",
    <%= encode_attributes(faction.attributes) %>
  )
);
<% end %>

<%= for {id, group} <- @game.groups do %>
game.addGameObject(
  new RezGroup(
    "<%= id %>",
    <%= encode_attributes(group.attributes) %>
  )
);
<% end %>

<%= for {id, inventory} <- @game.inventories do %>
game.addGameObject(
  new RezInventory(
      "<%= id %>",
      <%= encode_attributes(inventory.attributes) %>
    )
);
<% end %>

<%= for {id, item} <- @game.items do %>
game.addGameObject(
  new RezItem(
    "<%= id %>",
    <%= if is_nil(item.template) do %>
      null
    <% else %>
      Handlebars.template(<%= item.template %>)
    <% end %>,
    <%= encode_attributes(item.attributes) %>
  )
);
<% end %>

<%= for {id, list} <- @game.lists do %>
game.addGameObject(
  new RezList(
    "<%= id %>",
    <%= encode_attributes(list.attributes) %>
  )
);
<% end %>

<%= for {id, plot} <- @game.plots do %>
game.addGameObject(
  new RezPlot(
    "<%= id %>",
    <%= encode_attributes(plot.attributes) %>
  )
);
<% end %>

<%= for {id, relationship} <- @game.relationships do %>
game.addGameObject(
  new RezRelationship(
    "<%= id %>",
    <%= encode_attributes(relationship.attributes) %>
  )
);
<% end %>

<%= for {id, scene} <- @game.scenes do %>
game.addGameObject(
  new RezScene(
    "<%= id %>",
    Handlebars.template(<%= scene.layout_template %>),
    <%= encode_attributes(scene.attributes) %>
  )
);
<% end %>

<%= for {slot_id, slot} <- @game.slots do %>
game.addGameObject(
  new RezSlot(
    "<%= slot_id %>",
    <%= encode_attributes(slot.attributes) %>
  )
);
<% end %>

<%= for {id, system} <- @game.systems do %>
game.addGameObject(
  new RezSystem(
    "<%= id %>",
    <%= encode_attributes(system.attributes) %>
  )
);
<% end %>

<%= for {id, topic} <- @game.topics do %>
game.addGameObject(
  new RezTopic(
    "<%= id %>",
    <%= encode_attributes(topic.attributes) %>
  )
);
<% end %>

<%= for {id, zone} <- @game.zones do %>
  let zone = new RezZone(
    "<%= id %>",
    <%= encode_attributes(zone.attributes) %>
  )

  game.addGameObject(zone);

  <%= for {loc_id, location} <- zone.locations do %>
    let location_<%= loc_id %> = new RezLocation(
      "<%= loc_id %>",
      <%= if is_nil(location.template) do %>
      null
      <% else %>
      Handlebars.template(<%= location.template %>)
      <% end %>,
      <%= encode_attributes(location.attributes) %>
    );

    zone.addLocation(location_<%= loc_id %>);
    game.addGameObject(location_<%= loc_id %>);
  <% end %>
<% end %>

<%= for {id, object} <- @game.objects do %>
  game.addGameObject(
    new RezObject(
      "<%= id %>",
      <%= encode_attributes(object.attributes) %>
    )
  )
<% end %>

window.$ = (id) => game.$(id);
window.$game = game;

})();
