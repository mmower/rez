// Auto-generated by Rez v<%= Rez.version %>
// Do not modify as it will be overwritten when the game is next compiled.

(function() {
  window.Rez = window.Rez ?? {};

  Rez.mods = [];

  Rez.typeHierarchy = <%= @type_hierarchy %>;

  Rez.isTypeOf = function(type, targetType) {
    if (type === targetType) return true;
    const parents = Rez.typeHierarchy[type];
    if (!parents) return false;
    for (const parent of parents) {
      if (Rez.isTypeOf(parent, targetType)) return true;
    }
    return false;
  };

  Rez.registerMod = function(name, initFn) {
    if (typeof initFn !== "function") {
      console.error("Mod " + name + " does not provide an init function");
      return;
    }
    Rez.mods.push({name: name, initFn: initFn});
  };

  Rez.loadMods = function() {
    return new Promise(function(resolve) {
      var script = document.createElement("script");
      script.src = "mods.js";
      script.onload = function() {
        var modPaths = Rez.modManifest || [];
        var next = function(i) {
          if (i >= modPaths.length) return resolve();
          Rez.loadMod(modPaths[i]).then(function() { next(i + 1); });
        };
        next(0);
      };
      script.onerror = function() {
        resolve();
      };
      document.head.appendChild(script);
    });
  };

  Rez.loadMod = function(url) {
    return new Promise(function(resolve) {
      const modCount = Rez.mods.length;
      const script = document.createElement("script");
      script.src = url;
      script.onload = function() {
        if (Rez.mods.length === modCount) {
          console.warn("Mod " + url + " loaded but did not call Rez.registerMod()");
        }
        resolve();
      };
      script.onerror = function() {
        console.error("Failed to load mod: " + url);
        resolve();
      };
      document.head.appendChild(script);
    });
  };

  <%= @constants %>
  <%= @patch_js_objects %>
  <%= @js_stdlib %>
  <%= @js_userlib %>

  <%= @mixins %>
  <%= @register_expression_filters %>
  <%= @init_game_objects %>
  <%= @bind_keys %>
  <%= @user_components %>

  window.$ = (id, show_throw = false) => game.getGameObject(id, show_throw);
  window.$t = (id, element, should_throw = false) => game.getTypedGameObject(id, element, should_throw);

  /* @function isElementRef
   * @memberof RezGame
   * @param {*} value value to check
   * @returns {boolean} true if value is an element reference object
   * @description checks if a value is an element reference in {$ref: "id"} format
   */
  Rez.isElementRef = (value) => value && typeof value === 'object' && '$ref' in value;

  /**
   * @function extractId
   * @memberof RezGame
   * @param {string|object} idOrRef either a string ID or a {$ref: "id"} object
   * @returns {string} the extracted ID string
   * @description extracts ID from either plain string or {$ref: "id"} format
   */
  Rez.extractId = (idOrRef) => {
    if (typeof idOrRef === 'string') return idOrRef;
    if (idOrRef?.$ref) return idOrRef.$ref;
    throw new Error(`Invalid reference format: ${String(idOrRef)}`);
  };

  window.$game = game;

  window.range = function*(sv, ev) {
    for(let ix = sv; ix <= ev; ix += 1) {
      yield ix;
    }
  }

  if(window.$game.getAttributeValue("$warn_before_reload", false)) {
    window.addEventListener("beforeunload", (evt) => {
      evt.preventDefault();
      evt.returnValue = "";
    });
  }
})();
