= JavaScript API
:toc:
:toclevels: 1

This document describes Rez's Javascript API including the objects which are the counterparts of the Rez elements. In general there is a 1:1 mapping from a game element to a Javascript object, e.g. `@card` maps to `RezCard`.

Most of the `RezXXX` objects have <<basic_object, basic_object>> as a prototype so its important to familiarize yourself with that API.

== basic_object

The `basic_object` prototype provides a base layer of functionality to all game objects including operating the attribute, event, and storage models.

=== $(id)

Lookup another object via its `#id`.

=== init(level)

Call the appropriate init function given the level, e.g. `init(0)` invokes the `init_0` method. The framework ensures these functions are called, for all statically defined objects, when the game starts. However if you start creating them dynamically they will need to be initialized.

=== init_all()

Calls all init methods in turn.

=== init_0()

Initialize dynamic properties.

=== init_1()

Call `elementInitializer()` and send the object the `init` event.

=== init_2()

Sets the object as being initialized.

=== initDynamicProperties()

Iterate through the objects attributes looking for dynamic attributes and then call the appropriate method to create properties to access it.

=== createDynamicallyInitializedAttribute(attr_name, value)
=== createReferenceAttribute(attr_name, value)
=== createDynamicValueAttribute(attr_name, value)
=== createTraceryGrammarAttribute(attr_name, value)

=== elementInitializer()

This method is intended to be overriden in objects using `basic_object` as a prototype and is an opportunity to do specific initialization for that type of object.

=== copyAssigningId(id)



=== copyWithAutoId()

=== isTemplateObject()

=== eventHandler(event_name)

=== willHandleEvent(event_name)

=== runEvent(event_name, event_info)

=== getIn(path)

=== hasAttribute(name)

=== getAttribute(name)

=== getAttributeValue(name, default_value)

=== $av(name, default_value)

=== getObjectViaAttribute(name, default_value)

=== setObjectViaAttribute(name, object)

=== attributeHasChanged(attr_name)

=== setAttribute(name, value)

=== addTag(tag)

=== removeTag(tag)

=== setTags(new_tags)

=== putIn(path, value)

=== incAttribute(name, amount = 1)

=== decAttribute(name, amount = 1)

=== applyEffect(effect_id, item_id)

=== removeEffect(effect_id, item_id)

=== addBinding(name, object)

=== needsArchiving()

=== archiveDataContainer()

=== dataWithArchivedAttributes(data)

=== dataWithArchivedProperties(data)

=== toJSON()

=== loadData(data)

== RezActor

== RezAsset

== RezBlock

== RezCard

== RezDeactivateLinkTransformer

== RezDecision

== RezDieRoll

[cols="h,5a"]
|===
| new RezDieRoll(die, count, modifier, rounds)
|===

Constructs a new die roll, e.g. `new RezDieRoll(Rez.D6, 3, 1)` returns the result of rolling 3d6+1.

`die`: an instance of RezDie, typically use Rez.D4, Rez.D6, Rez.D8, Rez.D10, Rez.D12, Rez.D20, or Rez.D100 but you can construct your own.
`count`: number of die to roll
`modifier`: +/- integer modification to the sum of the die roll
`rounds`: default=1, number of rounds to average (CLRAND)

....
rollRound()
....

Rolls a single round (equivalent to `roll` where count=1).

....
roll()
....

Rolls `rounds` rounds and returns the average. This can be used to simulate a normal distribution of dice rolls where the middle of the range is more common. Adding more rounds will cause the rolls to tend more towards the middle of the range.

== RezDynamicLink

== RezEffect

== RezEventLinkTransformer

== RezFaction

== RezFormTransformer

== RezGame
=== API

==== archive()

Returns a JSON string containing the archived state of the game. This is used
internally by the save() call.

==== save()

Archives the current game state and triggers a file download of a JSON save
game. The file will automatically be named using the game name as a prefix and
the date & time as a suffix.

It works by adding the JSON to a `File` object and adding a link to the
document link to that `File` and automatically clicking it.

Before the download gets triggered a `save` event is raised allowing the game
an opportunity to make changes before state gets archived.

==== load(json)

Retrieves a game state from the passed in JSON and attempts to reload it first
checking that it has the same archive_version.

After the state has been reloaded a `load` event is raised giving the game an
opportunity to do any necessary work before the player sees the new state.

==== addGameObject(obj)

Adds a game object (one of the RezXXX object types) to the games database. Once
an object has been added it becomes available using `$(obj_id)`.

If the object has a `tags` attribute the object will be automatically indexed
against its tags and will appear in searches using `getTaggedWith(tag)`.

Note that unlike most other attributes it is inadvisable to use
`obj.setAttribute("tag", ...)` to update tags. The `setTags()`, `addTag()` and
`removeTag()` functions should be used instead and will automatically keep the
game tag-index up to date.

==== getGameObject(id, should_throw = true)

Retrieves the game object with id.

If `should_throw` is true (default: true) then an exception is thrown if the id
is not in the game database.

Returns:

`null` if the specified `id` is not in the game database
`ref` reference to the object with id `id`

The compiler attempts to ensure that invalid id references are not used however
this cannot be enforced when copies with dynamic ids get made.

==== getRelationship(source_id, target_id)

Returns a relationship from the source object towards the target object.

Returns:

`null` if there is no relationship from source to target
`ref` a `RezRelationship` from source to target

==== getTaggedWith(tag)

Get objects that have the tag.

Returns:

`[]` if there are no objects with the tag
`[...]` array of objects that have the tag

==== getAll(target_type)

Get objects that have the specified target type, e.g. 'actor', 'item', 'scene'.

Returns:

`[]` if there are no objects with this target type
`[...]` array of objects of the target type

==== getCurrentScene()

Get a reference to the current scene.

Returns:

`ref` reference to the current `RezScene`

==== setCurrentScene(new_scene_id)

Transitions from the current scene to a new scene with id `new_scene_id`.

The current scene will receive a call to `finish()` to give it an opportunity
to clean up.

The new scene will receive a call to `start()` to indicate it should get ready
to render.

==== getTarget(target_id)

This method will probably be deprecated when the renderer gets rewritten.

==== container()

Gets the HTML element that the game is rendered inside.

==== render()

Triggers a render pass.

The current scene is asked to render itself and the resulting content is passed
into the game layout template.

The `innerHTML` property of the HTML container is set to this content.

The scene is then given an opportunity to transform links, forms, inputs and so
on to add the `rez-live` functionality.

The inner workings of the render method are likely to change when the renderer
is rewritten. Do not depend upon them.

==== interludeWithScene(scene_id)

Interrupts the current scene with another scene.

Unlike when the scene is changed with `setCurrentScene` the old scene is
expected to be resumed.

The current scene gets a call to `interrupt` to notify it that it is being
interrupted and the new scene is started.

Interrupted scenes are held in a stack allowing an interrupted scene to,
itself, be interrupted.

Use `resumePrevScene` to return to the last scene in the stack.

==== resumePrevScene()

Use to return to the previous scene after an interruption.

The current scene will receive a call to `finish()` to let it know a scene
change is coming.

The last interrupted scene is then made the current scene again and receives a
call to `resume()` to let it know that its on stage again.

==== start(container_id)

Used to start the game and tells it which HTML element it should live inside.
An author should never need to call this as the framework does this
automatically.

==== getEnabledSystems()

Returns a list of `RezSystem` objects that have `enabled: true` and ordered by
`priority` with the highest priority system appearing first in the list.

Returns:

`[]` no systems are enabled
`[...]` a list of systems in increasing priority order

==== runTick()

Sends a `tick` event to all enabled systems returned by `getEnabledSystems`.

This area is not yet well thought out but the idea is that a 'tick' represents
a unit of game time and probably there is a correspondence between player
actions and ticks. After a player has taken an action use `runTick()` to allow
the game systems to respond.

For example a system might run actor behaviours, or create items, or whatever
your game needs.

There'll probably be more on this in the Cookbook as time goes on. Or maybe the
whole thing will get rewritten.

== RezGroup

== RezInputTransformer

== RezInventory

== RezItem

== RezList
=== API

==== randomElement()

`list.randomElement()`

Return a random element of the list.

==== nextForCycle()

`list.nextForCycle(key)`

Cycles through the list element by element. Each cycle is identified by a key.

==== randomUnique()

`list.randomUnique(key)`

Returns the next element in a random walk through the list elements. No element will be repeated in a walk. Walks are identified by a key.

== RezObject

== RezPlot

== RezRelationship
=== API


- `getAffinity()`
- `setAffinity(new_affinity)`
- `alterAffinity(change)`

== RezScene

== RezSingleLayout

== RezSlot

== RezStackLayout

== RezSystem

== RezTask

== RezTemplate

== RezView
